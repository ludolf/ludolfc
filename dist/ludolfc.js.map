{"version":3,"file":"ludolfc.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,mBAAO,CAAC,6BAAQ;AACvC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACtUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI,EAAE,WAAW,KAAK,SAAS,EAAE,WAAW,KAAK,QAAQ;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AChfA,aAAa,mBAAO,CAAC,6BAAQ;AAC7B,eAAe,mBAAO,CAAC,iCAAU;AACjC,kBAAkB,mBAAO,CAAC,uCAAa;AACvC;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,8BAA8B;AAC7C;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,mBAAmB;;;;;;;;;;;ACzDnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,mBAAO,CAAC,6BAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB,cAAc,kBAAkB;AACnF,gCAAgC,cAAc,cAAc,cAAc,kBAAkB,WAAW;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,cAAc;AACd,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,0GAA0G;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G;AAC5G;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,UAAU;AACpB;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU,UAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB;AACA;AACA,cAAc;AACd,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,aAAa;AAC9E;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,sDAAsD,EAAE,WAAW;AACnE;AACA;AACA;AACA,mDAAmD,EAAE,WAAW;AAChE;AACA;AACA;AACA,qDAAqD,EAAE,KAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UC9qBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://ludolfc/webpack/universalModuleDefinition","webpack://ludolfc/./src/interpret.js","webpack://ludolfc/./src/lang.js","webpack://ludolfc/./src/ludolfc.js","webpack://ludolfc/./src/parser.js","webpack://ludolfc/webpack/bootstrap","webpack://ludolfc/webpack/before-startup","webpack://ludolfc/webpack/startup","webpack://ludolfc/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ludolfc\"] = factory();\n\telse\n\t\troot[\"ludolfc\"] = factory();\n})(this, () => {\nreturn ","const { \r\n    Types,\r\n    Errors,\r\n    Interruptions,\r\n    InterpretError: LangInterpretError,\r\n    Interrupt: LangInterrupt,\r\n    Void: LangVoid } = require('./lang')\r\n\r\nclass Interpret {\r\n    constructor(imports = {}, controls, maxSteps = 100000) {\r\n        this.variables = new VariablesScope(imports)\r\n        this.stepper = new ExecutionStepper(maxSteps, controls && controls.isInterrupted) // to prevent infinite loops\r\n    }\r\n\r\n    async execute(ast) {\r\n        this.variables.clear()\r\n        this.stepper.reset()\r\n        return await this.executeBlock(ast, false)\r\n    }\r\n\r\n    async executeBlock(block, newScope = true) {        \r\n        if (newScope) this.variables.pushScope()\r\n        let result\r\n        for (let stm of block.statements) {\r\n            result = await this.executeStatement(stm)\r\n        }\r\n        if (newScope) this.variables.popScope()\r\n        return result ? result : new LangVoid()\r\n    }\r\n\r\n    async executeStatement(stm) {\r\n        this.stepper.step(stm.source)\r\n        return stm.isExpression ? await this.executeExpression(stm) :\r\n               stm.isAssignment ? await this.executeAssignment(stm) :\r\n               stm.isWhile ? await this.executeWhile(stm) :\r\n               stm.isIf ? await this.executeIf(stm) : \r\n               stm\r\n    }\r\n\r\n    async executeExpression(expression, assignNewValue = null) {\r\n        this.stepper.step(expression.source)\r\n        if (!expression.parts) throw new LangInterpretError(Errors.EMPTY_EXPRESSION, expression.source)\r\n        let parts = [...expression.parts]\r\n        return await this.executeExpressionParts(parts, assignNewValue)\r\n    }\r\n\r\n    async executeExpressionParts(parts, assignNewValue = null) {\r\n        // logical operators short circuit\r\n        let index = findFirstOp('&')\r\n        if (index) {\r\n            const left = await this.executeExpressionParts(parts.slice(0, index), assignNewValue)\r\n            if (left.type !== Types.BOOLEAN) throw new LangInterpretError(Errors.WRONG_BI_OPERATOR_SUBJECTS, left.source)\r\n            if (!left.value) return left\r\n            const right = await this.executeExpressionParts(parts.slice(index + 1), assignNewValue)\r\n            if (right.type !== Types.BOOLEAN) throw new LangInterpretError(Errors.WRONG_BI_OPERATOR_SUBJECTS, right.source)\r\n            return right\r\n        }\r\n        index = findFirstOp('|')\r\n        if (index) {\r\n            const left = await this.executeExpressionParts(parts.slice(0, index), assignNewValue)\r\n            if (left.type !== Types.BOOLEAN) throw new LangInterpretError(Errors.WRONG_BI_OPERATOR_SUBJECTS, left.source)\r\n            if (left.value) return left\r\n            const right = await this.executeExpressionParts(parts.slice(index + 1), assignNewValue)\r\n            if (right.type !== Types.BOOLEAN) throw new LangInterpretError(Errors.WRONG_BI_OPERATOR_SUBJECTS, right.source)\r\n            return right\r\n        }\r\n\r\n        // left to right by precendence\r\n        let assignApplied = false\r\n        while ((index = findNextOp()) > -1) {\r\n            const op = parts[index]\r\n\r\n            if (assignNewValue && !op.isObjectAccess && !op.isArrayAccess) throw new LangInterpretError(Errors.ACCESS_OPERATOR_EXPECTED, op.source)\r\n\r\n            try {\r\n                if (op.isUni) {\r\n                    const a = await this.executeExpressionPart(parts[index + 1])\r\n                    if (!a.type) throw new LangInterpretError(Errors.WRONG_UNI_OPERATOR_SUBJECT, op.source)\r\n                    parts[index] = op.apply(a)\r\n                    parts = removeElementAt(parts, index + 1)\r\n                } else \r\n                if (op.isBi) {\r\n                    const a = await this.executeExpressionPart(parts[index - 1])\r\n                    const b = await this.executeExpressionPart(parts[index + 1])\r\n                    if (!a.type || !b.type) throw new LangInterpretError(Errors.WRONG_BI_OPERATOR_SUBJECTS, op.source)\r\n                    if (a.type !== b.type) throw new LangInterpretError(Errors.UNMATCHING_BI_OPERATOR_SUBJECTS, op.source)\r\n                    parts[index] = op.apply(a, b)\r\n                    parts = removeElementAt(parts, index - 1, index + 1)\r\n                } else \r\n                if (op.isArrayAccess) {\r\n                    const a = await this.executeExpressionPart(parts[index - 1])\r\n                    if (Types.ARRAY !== a.type) throw new LangInterpretError(Errors.EXPECTED_ARRAY, op.source)\r\n                    if (assignNewValue && a.protected()) throw new LangInterpretError(Errors.PROTECTED_FROM_MODIFICATION, op.source)\r\n                    const indexes = await Promise.all(op.indexes.map(i => this.executeExpressionPart(i)))\r\n                    parts[index] = op.apply(a, indexes, (assignNewValue && isLastOperator()) ? assignNewValue : null)\r\n                    if (!parts[index]) throw new LangInterpretError(Errors.ATTRIBUTE_NOT_FOUND, op.source)\r\n                    parts = removeElementAt(parts, index - 1)\r\n                    assignApplied = true\r\n                } else \r\n                if (op.isObjectAccess) {\r\n                    const o = await this.executeExpressionPart(parts[index - 1])\r\n                    if (!o.isObject) throw new LangInterpretError(Errors.EXPECTED_OBJECT, op.source)\r\n                    if (assignNewValue && o.protected()) throw new LangInterpretError(Errors.PROTECTED_FROM_MODIFICATION, op.source)\r\n                    parts[index] = op.apply(o, (assignNewValue && isLastOperator()) ? assignNewValue : null)\r\n                    if (!parts[index]) throw new LangInterpretError(Errors.ATTRIBUTE_NOT_FOUND, op.source)\r\n                    parts = removeElementAt(parts, index - 1)\r\n                    assignApplied = true\r\n                } else \r\n                if (op.isCall) {\r\n                    const f = await this.executeExpressionPart(parts[index - 1])\r\n                    const params = await Promise.all(op.params.map(p => this.executeExpressionPart(p)))\r\n                    parts[index] = await this.executeFunctionCall(f, params)\r\n                    parts = removeElementAt(parts, index - 1)\r\n                }\r\n                else throw new LangInterpretError(Errors.UNKNOWN_OPERATOR, op.source)\r\n\r\n            } catch (e) {   // LangError could be raised from applying the operator in lang.js\r\n                if (e.isLangError) {\r\n                    if (!e.isInterpretError) throw new LangInterpretError(e.id, op.source, e.arg1, e.arg2)\r\n                } else {\r\n                    throw new LangInterpretError(Errors.UNKNOWN_ERROR, op.source, e)\r\n                }\r\n                throw e\r\n            }\r\n        }\r\n\r\n        if (assignNewValue && !assignApplied) throw new LangInterpretError(Errors.ACCESS_OPERATOR_EXPECTED, parts[0].source)\r\n\r\n        return await this.executeExpressionPart(parts[0]) // parts are reduced to a single result\r\n\r\n        function findNextOp() { // returns an index of the next part\r\n            let index = -1\r\n            let maxPrecedence = Number.MIN_SAFE_INTEGER\r\n            for (let i = 0; i < parts.length; i++) {\r\n                const op = parts[i]\r\n                if (!op.isOperator) continue\r\n                if (maxPrecedence < op.precedence || (op.isUni && maxPrecedence === op.precedence)) {\r\n                    index = i\r\n                    maxPrecedence = op.precedence\r\n                }\r\n            }\r\n            return index\r\n        }\r\n\r\n        function removeElementAt(arr, ...indexes) {\r\n            return arr.filter((_, i) => !indexes.includes(i))\r\n        }\r\n\r\n        function isLastOperator() {\r\n            return parts.length === 2\r\n        }\r\n\r\n        function findFirstOp(op) {\r\n            for (let i = 0; i < parts.length; i++)\r\n                if (parts[i].isBi && parts[i].op === op) return i\r\n        }\r\n    }\r\n\r\n    async executeExpressionPart(expressionPart) {\r\n        this.stepper.step(expressionPart.source)\r\n        \r\n        if (expressionPart.isReference) {\r\n            if (!this.variables.hasVariable(expressionPart.varName)) throw new LangInterpretError(Errors.UNREFERENCED_VARIABLE, expressionPart.source - expressionPart.varName.length, expressionPart.varName)\r\n            return this.variables.getVariable(expressionPart.varName)\r\n        }\r\n        if (expressionPart.isExpression) {\r\n            return await this.executeExpression(expressionPart)\r\n        }\r\n        if (Types.ARRAY === expressionPart.type) {\r\n            const arr = expressionPart.value\r\n            for (let i = 0; i < arr.length; i++) {\r\n                arr[i] = await this.executeExpressionPart(arr[i])\r\n            }\r\n        } else\r\n        if (Types.OBJECT === expressionPart.type) {\r\n            const obj = expressionPart.value\r\n            for (let k of Object.keys(obj)) {\r\n                obj[k] = await this.executeExpressionPart(obj[k])\r\n                if (obj[k].isObject || obj[k].isFunction) obj[k].parent = expressionPart\r\n            }\r\n        }\r\n        return expressionPart\r\n    }\r\n\r\n    async executeFunctionCall(f, params) {\r\n        if (f.isNative) {\r\n            const result = await f.call(...params)\r\n            return !result ? new LangVoid() : result\r\n        }\r\n\r\n        if ((!params && f.args) || params.length !== f.args.length) throw new LangInterpretError(Errors.FUNC_ARGUMENTS_MISHMASH, f.source)\r\n        // scoped variables\r\n        let i = 0\r\n        this.variables.pushScope()\r\n        for (let arg of f.args) {\r\n            this.variables.setVariable(arg, params[i++], true)\r\n        }\r\n        if (f.parent) {\r\n            // cache \"this\" object into variable $\r\n            this.variables.setVariable('$', f.parent, true)\r\n        }\r\n        \r\n        try {\r\n            const result = await this.executeBlock(f.body, false)\r\n            return result\r\n\r\n        } finally {  // clean up variables\r\n            this.variables.popScope()\r\n        }\r\n    }\r\n\r\n    async executeAssignment(assignment) {\r\n        if (!assignment.left || !assignment.right) throw new LangInterpretError(Errors.WRONG_ASSIGNMENT, assignment.source)\r\n        const value = await this.executeExpressionPart(assignment.right)        \r\n        // variable assignment\r\n        if (assignment.left.isVariable) {\r\n            const variable = this.variables.getVariable(assignment.left.name)\r\n            if (variable.protected && variable.protected()) throw new LangInterpretError(Errors.PROTECTED_FROM_MODIFICATION, assignment.left.source)\r\n            this.variables.setVariable(assignment.left.name, value)\r\n        } else\r\n        // object attribute or array element assignment\r\n        if (assignment.left.isExpression) {\r\n            await this.executeExpression(assignment.left, value)\r\n        }\r\n        else throw new LangInterpretError(Errors.WRONG_ASSIGNEE_TYPE)\r\n    }\r\n\r\n    async executeWhile(whileStm) {\r\n        if (!whileStm.condition || !whileStm.condition.isExpression) throw new LangInterpretError(Errors.WRONG_CONDITION, whileStm.source)\r\n        while (true) {\r\n            const cond = await this.executeExpressionPart(whileStm.condition)\r\n            if (cond.type !== Types.BOOLEAN) throw new LangInterpretError(Errors.WRONG_CONDITION_VALUE, cond.source)\r\n            if (cond.value) await this.executeBlock(whileStm.body)\r\n            else break\r\n        } \r\n    }\r\n\r\n    async executeIf(ifStm) {\r\n        if (!ifStm.condition || !ifStm.condition.isExpression) throw new LangInterpretError(Errors.WRONG_CONDITION, ifStm.source)\r\n        const cond = await this.executeExpressionPart(ifStm.condition)\r\n        if (cond.type !== Types.BOOLEAN) throw new LangInterpretError(Errors.WRONG_CONDITION_VALUE, cond.source)\r\n        if (cond.value) await this.executeBlock(ifStm.body)\r\n        else if (ifStm.elseBody) await this.executeBlock(ifStm.elseBody)\r\n    }\r\n}\r\n\r\nclass VariablesScope {\r\n    constructor(imports = {}) {\r\n        this.variables = [new Map()]\r\n        this.imports = imports\r\n    }\r\n\r\n    clear() {\r\n        this.variables = [new Map()]\r\n        if (this.imports) Object.entries(this.imports).forEach(([k,v]) => this.variables[0].set(k, v))\r\n    }\r\n\r\n    hasVariable(name) {\r\n        for (let i = this.variables.length - 1; i >= 0; i--) {\r\n            if (this.variables[i].has(name)) return true\r\n            if (this.variables[i].has('$')) {\r\n                const self = this.variables[i].get('$')\r\n                if (self.hasAttribute(name)) return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    getVariable(name) {\r\n        for (let i = this.variables.length - 1; i >= 0; i--) {\r\n            if (this.variables[i].has(name)) return this.variables[i].get(name)\r\n            if (this.variables[i].has('$')) {\r\n                const self = this.variables[i].get('$')\r\n                if (self.hasAttribute(name)) return self.attribute(name)\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    setVariable(name, value, scoped = false) {\r\n        if (scoped) {\r\n            this.variables[this.variables.length - 1].set(name, value)\r\n            return\r\n        }\r\n        let found = false\r\n        for (let i = this.variables.length - 1; i >= 0; i--) {\r\n            if (this.variables[i].has(name)) {\r\n                this.variables[i].set(name, value)\r\n                found = true\r\n                break\r\n            }\r\n        }\r\n        if (!found) {\r\n            if (!this.variables.length) this.clear()\r\n            this.variables[this.variables.length - 1].set(name, value)\r\n        }\r\n    }\r\n\r\n    pushScope() {\r\n        this.variables.push(new Map())\r\n    }\r\n\r\n    popScope() {\r\n        this.variables.pop()\r\n    }\r\n}\r\n\r\nclass ExecutionStepper {\r\n    constructor(maxSteps, isInterruptedFn) {\r\n        this.maxSteps = maxSteps\r\n        this.isInterruptedFn = isInterruptedFn\r\n        this.steps = 0        \r\n    }\r\n\r\n    step(source) {\r\n        if (this.isInterruptedFn && this.isInterruptedFn()) throw new LangInterrupt(Interruptions.USER_SUSSPEND)\r\n        this.steps++\r\n        if (this.steps > this.maxSteps) throw new LangInterpretError(Errors.EXECUTION_STEPS_EXCEEDED, source)\r\n    }\r\n\r\n    reset(maxSteps = null) {\r\n        this.steps = 0\r\n        if (maxSteps) this.maxSteps = maxSteps\r\n    }\r\n}\r\n\r\nmodule.exports = Interpret","const Keywords = {\r\n    TRUE: ['true', 'pravda', 'wahr'],\r\n    FALSE: ['false', 'nepravda', 'unwahr'],\r\n    IF: ['if', 'pokud', 'falls'],\r\n    ELSE: ['else', 'jinak', 'sonst'],\r\n    WHILE: ['while', 'dokud', 'soweit'],\r\n}\r\nconst SizeKeywords = ['size', 'velikost', 'größe']\r\nconst WhileKeywords = ['while', 'dokud', 'solange']\r\nconst IfKeywords = ['if', 'pokud', 'falls']\r\nconst ElseKeywords = ['else', 'jinak', 'sonst']\r\n\r\nconst Errors = {\r\n    INVALID_UNI_OPERATOR: 'INVALID_UNI_OPERATOR',\r\n    INVALID_BI_OPERATOR: 'INVALID_BI_OPERATOR',\r\n    UNEXPECTED_END: 'UNEXPECTED_END',\r\n    UNEXPECTED_SYMBOL: 'UNEXPECTED_SYMBOL',\r\n    EXPECTED_SYMBOL: 'EXPECTED_SYMBOL',\r\n    UNREFERENCED_VARIABLE: 'UNREFERENCED_VARIABLE',\r\n    UNEXPEXTED_KEYWORD: 'UNEXPEXTED_KEYWORD',\r\n    INVALID_IDENTIFIER: 'INVALID_IDENTIFIER',\r\n    UNEVEN_OPERATORS: 'UNEVEN_OPERATORS',\r\n    EXPECTED_FUNCTION: 'EXPECTED_FUNCTION',\r\n    EXPECTED_STATEMENT_END: 'EXPECTED_STATEMENT_END',\r\n    ARRAY_INDEX_NOT_NUMBER: 'ARRAY_INDEX_NOT_NUMBER',\r\n    ARRAY_INDEX_MISSING: 'ARRAY_INDEX_MISSING',\r\n    ARRAY_INDEX_OUT_BOUNDS: 'ARRAY_INDEX_OUT_BOUNDS',\r\n    FUNC_ARGUMENTS_MISHMASH: 'FUNC_ARGUMENTS_MISHMASH',\r\n    ATTRIBUTE_ALREADY_EXISTS: 'ATTRIBUTE_ALREADY_EXISTS',\r\n    ATTRIBUTE_NOT_FOUND: 'ATTRIBUTE_NOT_FOUND',\r\n    ELEMENT_NOT_FOUND: 'ELEMENT_NOT_FOUND',\r\n    EMPTY_EXPRESSION: 'EMPTY_EXPRESSION',\r\n    UNKNOWN_OPERATOR: 'UNKNOWN_OPERATOR',\r\n    OPERATOR_NOT_APPLICABLE: 'OPERATOR_NOT_APPLICABLE',\r\n    ACCESS_OPERATOR_EXPECTED: 'ACCESS_OPERATOR_EXPECTED',\r\n    WRONG_UNI_OPERATOR_SUBJECT: 'WRONG_UNI_OPERATOR_SUBJECT',\r\n    WRONG_BI_OPERATOR_SUBJECTS: 'WRONG_BI_OPERATOR_SUBJECTS',\r\n    UNMATCHING_BI_OPERATOR_SUBJECTS: 'UNMATCHING_BI_OPERATOR_SUBJECTS',\r\n    EXPECTED_ARRAY: 'EXPECTED_ARRAY',\r\n    EXPECTED_OBJECT: 'EXPECTED_OBJECT',\r\n    EXPECTED_IDENTIFIER: 'EXPECTED_IDENTIFIER',\r\n    WRONG_ASSIGNMENT: 'WRONG_ASSIGNMENT',\r\n    WRONG_ASSIGNEE_TYPE: 'WRONG_ASSIGNEE_TYPE',\r\n    READONLY_ATTRIBUTE: 'READONLY_ATTRIBUTE',\r\n    WRONG_CONDITION: 'WRONG_CONDITION',\r\n    WRONG_CONDITION_VALUE: 'WRONG_CONDITION_VALUE',\r\n    EXECUTION_STEPS_EXCEEDED: 'EXECUTION_STEPS_EXCEEDED',\r\n    PARSER_STEPS_EXCEEDED: 'PARSER_STEPS_EXCEEDED',\r\n    PROTECTED_FROM_MODIFICATION: 'PROTECTED_FROM_MODIFICATION',\r\n    DIVISION_BY_ZERO: 'DIVISION_BY_ZERO',\r\n    UNKNOWN_ERROR: 'UNKNOWN_ERROR',\r\n}\r\n\r\nconst Types = {\r\n    NUMBER: 'NUMBER',\r\n    BOOLEAN: 'BOOLEAN',\r\n    STRING: 'STRING',\r\n    ARRAY: 'ARRAY',\r\n    OBJECT: 'OBJECT',\r\n    FUNCTION: 'FUNCTION',\r\n    VOID: 'VOID',\r\n}\r\n\r\nconst Interruptions = {\r\n    USER_SUSSPEND: 'USER_SUSSPEND',\r\n}\r\n\r\nclass LangInterrupt {\r\n    constructor(id) {\r\n        this.id = id\r\n        this.isLangInterruption = true\r\n    }\r\n}\r\n\r\nclass LangError extends Error {\r\n    constructor(id, pos, arg1, arg2) {\r\n        super(id)\r\n        this.message = `${id} ${arg1 ? `\"${arg1}\"` : ''} ${arg2 ? `\"${arg2}\"` : ''}`\r\n        this.id = id\r\n        this.arg1 = arg1\r\n        this.arg2 = arg2\r\n        this.position = pos\r\n        this.isLangError = true\r\n    }\r\n}\r\n\r\nclass LangParseError extends LangError {\r\n    constructor(id, pos, arg1, arg2) {\r\n        super(id, pos, arg1, arg2)\r\n        this.isParseError = true\r\n    }\r\n}\r\n\r\nclass LangInterpretError extends LangError {\r\n    constructor(id, pos, arg1, arg2) {\r\n        super(id, pos, arg1, arg2)\r\n        this.isInterpretError = true\r\n    }\r\n}\r\n\r\nclass Block {\r\n    constructor(statements, source) {\r\n        this.statements = statements\r\n        this.source = source\r\n    }\r\n}\r\n\r\nclass Statement {\r\n    constructor(source) {\r\n        this.isExpression = false\r\n        this.isAssignment = false\r\n        this.isWhile = false\r\n        this.isIf = false\r\n        this.source = source\r\n    }\r\n}\r\n\r\nclass Assignment extends Statement {\r\n    constructor(left, right, source) {\r\n        super(source)\r\n        this.isAssignment = true\r\n        this.left = left\r\n        this.right = right\r\n    }\r\n}\r\n\r\nclass While extends Statement {\r\n    constructor(condition, body, source) {\r\n        super(source)\r\n        this.isWhile = true\r\n        this.condition = condition\r\n        this.body = body\r\n    }\r\n}\r\n\r\nclass If extends Statement {\r\n    constructor(condition, body, bodyElse, source) {\r\n        super(source)\r\n        this.isIf = true\r\n        this.condition = condition\r\n        this.body = body\r\n        this.elseBody = bodyElse\r\n    }\r\n}\r\n\r\nclass Expression extends Statement {\r\n    constructor(parts, source) {\r\n        super(source)\r\n        this.isExpression = true\r\n        this.parts = parts\r\n    }\r\n}\r\n\r\nclass Variable {\r\n    constructor(name, source) {\r\n        this.isVariable = true\r\n        this.name = name\r\n        this.source = source\r\n    }\r\n}\r\n\r\nclass Operator {\r\n    constructor(op, precedence = -1) {\r\n        this.op = op\r\n        this.isOperator = true\r\n        this.precedence = precedence\r\n    }\r\n}\r\n\r\nclass UniOperator extends Operator {\r\n    constructor(op, source) {\r\n        super(op)\r\n        this.isUni = true\r\n        this.precedence = this.getPrecedence()\r\n        this.source = source\r\n    }\r\n    apply(a) {\r\n        const fn = getFn(this.op)\r\n        if (!fn || !fn.call) throw new LangError(Errors.OPERATOR_NOT_APPLICABLE, null, this.op)\r\n        return fn.call()\r\n\r\n        function getFn(op) {\r\n            switch (op) {\r\n                case '!': \r\n                case '-': return a.neg\r\n                default: throw new LangError(Errors.INVALID_UNI_OPERATOR, null, this.op)\r\n            }\r\n        }\r\n    }\r\n    getPrecedence() { // based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n        switch (this.op) {\r\n            case '!':\r\n            case '-': return 14\r\n            default: -1\r\n        }\r\n    }\r\n}\r\n\r\nclass BiOperator extends Operator {\r\n    constructor(op, source) {\r\n        super(op)\r\n        this.isBi = true\r\n        this.precedence = this.getPrecedence()\r\n        this.source = source\r\n    }\r\n    apply(a, b) {\r\n        const fn = getFn(this.op)\r\n        if (!fn || !fn.call) {\r\n            if ('=' === this.op) return new LangBoolean(false)\r\n            throw new LangError(Errors.OPERATOR_NOT_APPLICABLE, null, this.op)\r\n        }\r\n        if ('/' === this.op && Types.NUMBER === b.type && b.value === 0) {\r\n            throw new LangError(Errors.DIVISION_BY_ZERO, null, this.op)\r\n        }\r\n        return fn.call(b)\r\n\r\n        function getFn(op) {\r\n            switch (op) {\r\n                case '*': return a.mult\r\n                case '/': return a.div\r\n                case '%': return a.mod\r\n                case '+': return a.plus\r\n                case '-': return a.minus\r\n                case '<': return a.lt\r\n                case '<=': return a.le\r\n                case '>': return a.gt\r\n                case '>=': return a.ge\r\n                case '=': return a.eq\r\n                case '!=': return a.ne\r\n                case '&': return a.and\r\n                case '|': return a.or\r\n                default: throw new LangError(Errors.INVALID_BI_OPERATOR, null, this.op)\r\n            }\r\n        }\r\n    }\r\n    getPrecedence() { // based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n        switch (this.op) {\r\n            case '*':\r\n            case '/':\r\n            case '%': return 12\r\n            case '+': \r\n            case '-': return 11\r\n            case '<': \r\n            case '<=':\r\n            case '>':\r\n            case '>=': return 9\r\n            case '=': \r\n            case '!=': return 8\r\n            case '&': return 4\r\n            case '|': return 3\r\n            default: -1\r\n        }\r\n    }\r\n}\r\n\r\nclass ArrayAccess extends Operator {\r\n    constructor(indexes, source) {\r\n        super('[]', 17)\r\n        this.isAccess = true\r\n        this.isArrayAccess = true\r\n        this.indexes = indexes\r\n        this.source = source\r\n    }\r\n    apply(a, indexes, newValue) { // indexes are resolved, but this.indexes are AST (expressions)\r\n        return a.element(indexes, newValue)\r\n    }\r\n}\r\n\r\nclass ObjectAccess extends Operator {\r\n    constructor(attrName, source) {\r\n        super('.', 17)\r\n        this.isAccess = true\r\n        this.isObjectAccess = true\r\n        this.attrName = attrName\r\n        this.source = source\r\n    }\r\n    apply(o, newValue) {\r\n        return o.attribute(this.attrName, newValue)\r\n    }\r\n}\r\n\r\nclass FunctionCall extends Operator {\r\n    constructor(params, source) {\r\n        super('()', 17)\r\n        this.isAccess = true\r\n        this.isCall = true\r\n        this.params = params\r\n        this.source = source\r\n    }\r\n}\r\n\r\nclass VarReference {\r\n    constructor(varName, source) {\r\n        this.isReference = true\r\n        this.varName = varName\r\n        this.source = source\r\n    }\r\n}\r\n\r\nclass LangObject {\r\n    constructor(obj, source, type = Types.OBJECT) {\r\n        this.value = obj\r\n        this.type = type\r\n        this.isObject = true\r\n        this.parent = null\r\n        this.source = source\r\n\r\n        this.eq = new LangNativeFunction(x => new LangBoolean(areObjectsEqual(this, x)))\r\n        this.ne = new LangNativeFunction(x => new LangBoolean(!(this.eq.call(x).value)))\r\n    }\r\n    attribute(name, newValue) {\r\n        const value = this[name] ? this[name] : this.value[name] // explicit attrs have priority over native ones\r\n        if (newValue && this.value[name]) this.value[name] = newValue\r\n        if (value) return value\r\n        if (this.parent) return this.parent.attribute(name)\r\n    }\r\n    hasAttribute(name) {\r\n        const hasValue = this[name] || this.value[name]\r\n        return hasValue || (this.parent && this.parent.hasAttribute(name))\r\n    }\r\n    protected() {\r\n        return this.isProtected || (this.parent && this.parent.protected())\r\n    }\r\n}\r\n\r\nclass LangValueObject extends LangObject {\r\n    constructor(value, source, type) {\r\n        super(value, source, type)\r\n\r\n        this.eq = new LangNativeFunction(x => new LangBoolean(this.value === x.value))\r\n        this.ne = new LangNativeFunction(x => new LangBoolean(this.value !== x.value))\r\n    }\r\n}\r\n\r\nclass LangNumber extends LangValueObject {\r\n    constructor(value, source) {\r\n        super(value, source, Types.NUMBER)\r\n        \r\n        this.mult = new LangNativeFunction(x => new LangNumber(this.value * x.value))\r\n        this.div = new LangNativeFunction(x => new LangNumber(this.value / x.value))\r\n        this.mod = new LangNativeFunction(x => new LangNumber(this.value % x.value))\r\n        this.plus = new LangNativeFunction(x => new LangNumber(this.value + x.value))\r\n        this.minus = new LangNativeFunction(x => new LangNumber(this.value - x.value))\r\n        this.lt = new LangNativeFunction(x => new LangBoolean(this.value < x.value))\r\n        this.le = new LangNativeFunction(x => new LangBoolean(this.value <= x.value))\r\n        this.gt = new LangNativeFunction(x => new LangBoolean(this.value > x.value))\r\n        this.ge = new LangNativeFunction(x => new LangBoolean(this.value >= x.value))\r\n        this.neg = new LangNativeFunction(() => new LangNumber(-this.value))\r\n        this.sum = new LangNativeFunction((...x) => new LangNumber(x.reduce((a,c) => a + c.value, this.value)))\r\n    }\r\n}\r\n\r\nclass LangString extends LangValueObject {\r\n    constructor(value, source) {\r\n        super(value, source, Types.STRING)\r\n\r\n        this.concat = new LangNativeFunction(x => new LangString(this.value + x.value))\r\n        this.length = new LangNativeFunction(() => new LangNumber(this.value.length))\r\n        \r\n        this.plus = this.concat\r\n        for (let s of SizeKeywords) this[s] = new LangNumber(this.value.length)\r\n    }\r\n}\r\n\r\nclass LangBoolean extends LangValueObject {\r\n    constructor(value, source) {\r\n        super(value, source, Types.BOOLEAN)\r\n\r\n        this.and = new LangNativeFunction(x => new LangBoolean(this.value && x.value))\r\n        this.or = new LangNativeFunction(x => new LangBoolean(this.value || x.value))\r\n        this.xor = new LangNativeFunction(x => new LangBoolean(this.value ? !x.value : x.value))\r\n        this.nand = new LangNativeFunction(x => new LangBoolean(!(this.value && x.value)))\r\n        this.neg = new LangNativeFunction(() => new LangBoolean(!this.value))\r\n\r\n        this.mult = this.and\r\n        this.plus = this.or\r\n    }\r\n}\r\n\r\nclass LangArray extends LangValueObject {\r\n    constructor(value, source) {\r\n        super(value, source, Types.ARRAY)\r\n\r\n        this.concat = new LangNativeFunction(x => new LangArray(this.value.concat(x.value)))\r\n\r\n        this.plus = this.concat\r\n        for (let s of SizeKeywords) this[s] = new LangNumber(this.value.length)\r\n\r\n        this.eq = new LangNativeFunction(x => {\r\n            if (!x || !x.value) return new LangBoolean(false)\r\n            if (this.value.length !== x.value.length) return new LangBoolean(false)\r\n            for (let i = 0; i < this.value.length; i++)\r\n                if (!this.value[i].eq || !this.value[i].eq.isNative || !this.value[i].eq.call(x.value[i]).value) return new LangBoolean(false)\r\n            return new LangBoolean(true)\r\n        })\r\n        this.ne = new LangNativeFunction(x => new LangBoolean(!(this.eq.call(x).value)))\r\n    }\r\n    element(indexes, newValue) {\r\n        return indexes.reduce((a,c,i) => {\r\n            const index = Math.ceil(c.value)\r\n            if (index < 0 || index >= a.value.length) throw new LangError(Errors.ARRAY_INDEX_OUT_BOUNDS)\r\n            const v = a.value[index]\r\n            // set the value for the last element\r\n            if (newValue && i === indexes.length - 1)\r\n                a.value[index] = newValue            \r\n            return v\r\n        }, this)\r\n    }\r\n    attribute(name, newValue) {\r\n        if (SizeKeywords.includes(name.toLowerCase())) {\r\n            if (newValue) throw new LangError(Errors.READONLY_ATTRIBUTE)\r\n            return new LangNumber(this.value.length)\r\n        }\r\n        return super.attribute(name, newValue)\r\n    }\r\n    hasAttribute(name) {\r\n        return SizeKeywords.includes(name.toLowerCase()) || super.attribute(name, newValue)\r\n    }\r\n}\r\n\r\nclass LangVoid extends LangValueObject {\r\n    constructor(source) {\r\n        super(null, source, Types.VOID)\r\n\r\n        this.eq = new LangNativeFunction(x => new LangBoolean(false))\r\n        this.ne = new LangNativeFunction(x => new LangBoolean(false))\r\n    }\r\n}\r\n\r\nclass LangFunction {\r\n    constructor(body, args, source) {\r\n        this.type = Types.FUNCTION\r\n        this.body = body\r\n        this.args = args\r\n        this.isFunction = true\r\n        this.source = source\r\n\r\n        this.eq = new LangNativeFunction(x => new LangBoolean(false))\r\n        this.ne = new LangNativeFunction(x => new LangBoolean(true))\r\n    }\r\n}\r\n\r\nclass LangNativeFunction {\r\n    constructor(func, source) {\r\n        this.type = Types.FUNCTION\r\n        this.func = func\r\n        this.isNative = true\r\n        this.source = source\r\n    }\r\n    call(...params) {\r\n        return this.func(...params)\r\n    }\r\n}\r\n\r\nfunction areObjectsEqual(a, b) {\r\n    const aKeys = Object.keys(a.value)\r\n    const bKeys = Object.keys(b.value)\r\n    if (aKeys.length !== bKeys.length) return false\r\n    for (k of aKeys) {\r\n        if (!a.value[k].eq.call(b.value[k])) return false\r\n    }\r\n    return true\r\n}\r\n\r\nmodule.exports = {\r\n    Keywords,\r\n    Errors,\r\n    Interruptions,\r\n    Types,\r\n    SizeKeywords,\r\n    WhileKeywords,\r\n    IfKeywords,\r\n    ElseKeywords,\r\n    Block,\r\n    Assignment,\r\n    While,\r\n    If,\r\n    Expression,\r\n    Variable,\r\n    UniOperator,\r\n    BiOperator,\r\n    ArrayAccess,\r\n    ObjectAccess,\r\n    FunctionCall,\r\n    VarReference,\r\n    ParseError: LangParseError,\r\n    InterpretError: LangInterpretError,\r\n    Interrupt: LangInterrupt,\r\n    Object: LangObject,\r\n    Number: LangNumber,\r\n    String: LangString,\r\n    Boolean: LangBoolean,\r\n    Array: LangArray,\r\n    Function: LangFunction,\r\n    NativeFunction: LangNativeFunction,\r\n    Void: LangVoid,\r\n}","const lang = require('./lang')\r\nconst Parser = require('./parser')\r\nconst Interpret = require('./interpret')\r\n\r\nclass LudolfC {\r\n    /**\r\n     * @param {object} imports \r\n     * @param {isInterrupted: () => boolean} controls \r\n     */\r\n    constructor(imports = {}, controls = {}) {\r\n        this.parser = new Parser()\r\n        this.interpret = new Interpret(imports, controls)\r\n    }\r\n\r\n    /**\r\n     * Execute LudolfC code.\r\n     * @param {string} code \r\n     * @returns result of the execution\r\n     */\r\n    async execute(code) {\r\n        try {\r\n            const ast = this.parser.parse(code)\r\n            return await this.interpret.execute(ast)\r\n\r\n        } catch (e) {\r\n            if (e.isLangError && (e.position || e.position === 0)) {\r\n                const {line, col} = lineAndCol(code, e.position)\r\n                e.line = line\r\n                e.col = col\r\n            }\r\n            throw e\r\n        }\r\n    }\r\n\r\n    hasVariable(name) {\r\n        return this.interpret.variables.hasVariable(name)\r\n    }\r\n\r\n    getVariable(name) {\r\n        return this.interpret.variables.getVariable(name)\r\n    }\r\n}\r\n\r\nfunction lineAndCol(code, position) {\r\n    let line = 1    // starting from 1\r\n    let col = 1\r\n    for (let i = 0; i < code.length && i <= position; i++) {\r\n        col++\r\n        if ('\\n' === code[i]) {\r\n            line++\r\n            col = 1\r\n        }\r\n    }\r\n    col = Math.max(1, col - 1)\r\n    return {line, col}\r\n}\r\n\r\nmodule.exports = { LudolfC, lang }\r\n","const { \r\n    Errors,\r\n    Keywords,\r\n    WhileKeywords,\r\n    IfKeywords,\r\n    ElseKeywords,\r\n    Block,\r\n    Assignment,\r\n    While,\r\n    If,\r\n    Expression,\r\n    Variable,\r\n    UniOperator,\r\n    BiOperator,\r\n    ArrayAccess,\r\n    ObjectAccess,\r\n    FunctionCall,\r\n    VarReference,\r\n    ParseError: LangParseError,\r\n    Object: LangObject,\r\n    Number: LangNumber,\r\n    String: LangString,\r\n    Boolean: LangBoolean,\r\n    Array: LangArray,\r\n    Function: LangFunction,\r\n    Void: LangVoid } = require('./lang')\r\n\r\nconst UniOperators = ['!', '-']\r\nconst BiOperators = ['*', '/', '%', '+', '-', '<', '<=', '>', '>=', '=', '!=', '&', '|']\r\n\r\nconst RE_NATIONAL_CHARS = `ěščřžťďýáíéúůüöäñĚŠČŘŽŤĎÝÁÍÉÚŮÜÖÄÑß`\r\nconst RE_IDENTIFIER = `[a-zA-Z_${RE_NATIONAL_CHARS}][a-zA-Z0-9_${RE_NATIONAL_CHARS}]*`\r\nconst RE_FUNCTION = `\\\\((\\\\s*(${RE_IDENTIFIER})\\\\s*(,\\\\s*(${RE_IDENTIFIER}))*)?\\\\s*\\\\)\\\\s*\\{(.|\\\\s)*\\\\}`\r\n\r\nclass Source {\r\n    constructor(code, startingAt = 0) {\r\n        this.code = code + '\\n'\r\n        this.pos = 0\r\n        this.startingAt = startingAt\r\n    }\r\n\r\n    move(step = 1) {\r\n        this.pos += step\r\n    }\r\n\r\n    currentChar() {\r\n        return this.code[this.pos]\r\n    }\r\n\r\n    remaining(length = undefined) {\r\n        return this.code.substring(this.pos, Math.min(length ? this.pos + length : this.code.length - 1, this.code.length - 1))\r\n    }\r\n\r\n    next(length = 1) {\r\n        return this.code.substring(Math.min(this.pos + 1, this.code.length - 1), Math.min(this.pos + 1 + length, this.code.length - 1))\r\n    }\r\n\r\n    finished() {\r\n        return this.pos >= this.code.length\r\n    }\r\n\r\n    absPos() {\r\n        return this.pos + this.startingAt - /* last move */ 1 \r\n    }\r\n}\r\n\r\nclass Parser {\r\n    constructor() {    \r\n        this.steps = 0\r\n        this.maxSteps = 1000000 // to prevent infinite loops\r\n    }\r\n\r\n    parse(code) {\r\n        this.steps = 0\r\n        return this.parseBlock(new Source(code))\r\n    }\r\n\r\n    parseBlock(source) {\r\n        const statements = []\r\n        while (!source.finished()) {\r\n            const stm = this.parseStatement(source)\r\n            if (stm) statements.push(stm)\r\n        }\r\n        return new Block(statements, source.absPos())\r\n    }\r\n\r\n    parseStatement(source) {\r\n        this._stepper()\r\n\r\n        let token = ''\r\n        \r\n        let expecting = null\r\n        let inAssignment = false\r\n\r\n        const openDefinitions = {\r\n            arrays: 0,  // [\r\n            objects: 0, // {\r\n        }\r\n\r\n        for (; !source.finished(); source.move()) {\r\n            this._stepper()\r\n\r\n            const c = source.currentChar()\r\n\r\n            // comment\r\n            if (isComment(source.remaining())) {\r\n                consumeUntil(source, '\\\\n')\r\n                continue\r\n            }\r\n            \r\n            // consume the whole string to prevent space-ignoring\r\n            if (!inAssignment && isStringStarting(c)) {\r\n                let cc = c\r\n                do {\r\n                    token += cc\r\n                    source.move()\r\n                    cc = source.currentChar()\r\n                } while (!source.finished() && !isStringEnding(cc, c))\r\n            }\r\n            \r\n            // ignore spaces (except space between numbers)\r\n            if (!expecting && isSpace(c) && isSpace(token.charAt(token.length - 1))) continue\r\n\r\n            if (expecting && c !== expecting) {\r\n                throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), expecting, c)\r\n            }\r\n            if (expecting === '=' && c === expecting) {\r\n                inAssignment = true\r\n                expecting = null\r\n                continue\r\n            }\r\n\r\n            if ('[' === c) openDefinitions.arrays++\r\n            if (']' === c) openDefinitions.arrays--\r\n            if ('{' === c) openDefinitions.objects++\r\n            if ('}' === c) openDefinitions.objects--\r\n\r\n            // end of the statement\r\n            if (isStatementSeparator(c) && !openDefinitions.arrays && !openDefinitions.objects) {\r\n                source.move()\r\n                break\r\n            }\r\n\r\n            // while\r\n            if (isWhileDef(source.remaining())) {\r\n                if (token.length) {\r\n                    throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), token)\r\n                }\r\n                consumeSpaces(source)\r\n                consumeUntil(source, '\\\\s')\r\n                const def = this.parseWhile(source)\r\n                consumeSpaces(source, true)\r\n                if (!isStatementSeparator(source.currentChar())) throw new LangParseError(Errors.EXPECTED_STATEMENT_END, source.absPos())\r\n                return def\r\n            }\r\n\r\n            // if\r\n            if (isIfDef(source.remaining())) {\r\n                if (token.length) {\r\n                    throw new LangParseError(Errors.UNEXPECTED_SYMBOL, token)\r\n                }\r\n                consumeSpaces(source)\r\n                consumeUntil(source, '\\\\s')\r\n                const def = this.parseIf(source)\r\n                consumeSpaces(source, true)\r\n                if (isElseDef(source.remaining())) {\r\n                    consumeSpaces(source)\r\n                    consumeUntil(source, '\\\\s')\r\n                    def.elseBody = this.parseBody(source)\r\n                    consumeSpaces(source, true)\r\n                }\r\n                if (!isStatementSeparator(source.currentChar())) throw new LangParseError(Errors.EXPECTED_STATEMENT_END, source.absPos())\r\n                if (!def.elseBody) {\r\n                    consumeSpaces(source)\r\n                    if (isElseDef(source.remaining())) {\r\n                        consumeSpaces(source)\r\n                        consumeUntil(source, '\\\\s')\r\n                        def.elseBody = this.parseBody(source)\r\n                        consumeSpaces(source, true)\r\n                        if (!isStatementSeparator(source.currentChar())) throw new LangParseError(Errors.EXPECTED_STATEMENT_END, source.absPos())\r\n                    }\r\n                }\r\n                return def\r\n            }\r\n\r\n            if (':' === c && !openDefinitions.objects) {    // assignment starting\r\n                if (!(token.trim().length)) throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), c)\r\n                if (isKeyword(token.trim())) throw new LangParseError(Errors.UNEXPEXTED_KEYWORD, source.absPos(), c)\r\n                expecting = '='\r\n            } else\r\n            if (inAssignment) {  // variable assignment                \r\n                const value = this.parseExpression(source, openDefinitions)\r\n                token = token.trim()\r\n                if (isIdentifier(token)) {\r\n                    const variable = new Variable(token, source.absPos())\r\n                    const assignment = new Assignment(variable, value, source.absPos())\r\n                    return assignment\r\n                } else {\r\n                    const exp = this.parseExpression(new Source(token, source.absPos() - token.length), {})\r\n                    if (!exp || exp.parts.some(p => p.isOperator && !p.isAccess))\r\n                        throw new LangParseError(Errors.INVALID_IDENTIFIER, source.absPos(), token)\r\n                    const assignment = new Assignment(exp, value, source.absPos())\r\n                    return assignment\r\n                }\r\n            }\r\n            else {\r\n                token += c\r\n            }\r\n        }\r\n\r\n        // statement is an expression\r\n        if (token.length) {\r\n            const exp = this.parseExpression(new Source(token, source.absPos() - token.length), {})\r\n            return exp\r\n        }\r\n    }\r\n\r\n    parseExpression(source, openDefinitions, inGrouping = null) {\r\n        this._stepper()\r\n\r\n        const parts = []\r\n\r\n        while (!source.finished()) {\r\n            this._stepper()\r\n\r\n            const c = source.currentChar()\r\n\r\n            // spaces\r\n            if (isSpace(c)) {\r\n                source.move()\r\n                continue\r\n            }\r\n\r\n            // end of the statement\r\n            if (isStatementSeparator(c) || ')' === c || ']' === c || '}' === c || ',' === c) {\r\n                if ((')' === c || ']' === c || '}' === c) && ((!inGrouping && inGrouping !== c) || !parts.length)) {\r\n                    throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), c)\r\n                }\r\n                // return the list of tokens and operators\r\n                if (parts.length) {\r\n                    if (parts[parts.length - 1].isOperator && !parts[parts.length - 1].isAccess) {\r\n                        throw new LangParseError(Errors.UNEVEN_OPERATORS, source.absPos())\r\n                    }\r\n                    return new Expression(parts, source.absPos())\r\n                }\r\n                source.move()\r\n                continue\r\n            }\r\n\r\n            // function defition\r\n            if (isFunctionDef(source.remaining())) {\r\n                if (parts.length && !parts[parts.length - 1].isOperator) {\r\n                    throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), c)\r\n                }\r\n                const fn = this.parseFunction(source)\r\n                parts.push(fn)\r\n                continue\r\n            }\r\n\r\n            // object definition\r\n            if ('{' === c) {\r\n                if (!leftOperatorExpected()) {\r\n                    throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), c)\r\n                }\r\n                source.move()\r\n                const attributes = this.readAttributes(source, ')')\r\n\r\n                consumeSpaces(source)\r\n                if ('}' === source.currentChar()) {\r\n                    const obj = new LangObject(attributes, source.absPos())\r\n                    // set the self reference\r\n                    for (let attr of Object.values(attributes)) {\r\n                        if (attr.isObject) {\r\n                            attr.parent = obj\r\n                        }\r\n                    }\r\n                    parts.push(obj)                    \r\n                    source.move()\r\n                    openDefinitions.objects--\r\n                    continue\r\n                }\r\n                throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), source.currentChar(), '}')\r\n            }\r\n\r\n            // grouping or a function call\r\n            if ('(' === c) {\r\n                source.move()\r\n                if (rightOperatorExpected()) {    // a function call\r\n                    const params = this.readList(source, ')')\r\n                    consumeSpaces(source)\r\n    \r\n                    if (')' === source.currentChar()) {\r\n                        var call = new FunctionCall(params, source.absPos())\r\n                        parts.push(call)\r\n                        source.move()\r\n                    } else {\r\n                        throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), source.currentChar(), ')')\r\n                    }\r\n                } else {    // grouping\r\n                    const exp = this.parseExpression(source, openDefinitions, true)\r\n                    parts.push(exp)\r\n                    consumeSpaces(source)\r\n                    if (')' !== source.currentChar()) throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), ')')\r\n                    source.move()\r\n                }\r\n                continue\r\n            }\r\n\r\n            // object attribute access\r\n            if ('.' === c && rightOperatorExpected()) {\r\n                source.move()\r\n                const attrName = this.readIdentifier(source)               \r\n                parts.push(new ObjectAccess(attrName, source.absPos()))\r\n                continue\r\n            }\r\n\r\n            // array\r\n            if ('[' === c) {\r\n                source.move()\r\n                if (rightOperatorExpected()) { // array access\r\n                    const indexes = this.readList(source, ']')\r\n                    consumeSpaces(source)\r\n\r\n                    if (!indexes.length) throw new LangParseError(Errors.ARRAY_INDEX_MISSING, source.absPos())\r\n\r\n                    if (']' === source.currentChar()) {\r\n                        if (indexes.some(i => !i.isExpression || !i.parts.length)) throw new LangParseError(Errors.ARRAY_INDEX_NOT_NUMBER, source.absPos())\r\n                        source.move()\r\n                        parts.push(new ArrayAccess(indexes, source.absPos()))\r\n                    } else {\r\n                        throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), source.currentChar(), ']')\r\n                    }\r\n                } else {    // array definition\r\n                    const elements = this.readList(source, ']')\r\n                    consumeSpaces(source)\r\n    \r\n                    if (']' === source.currentChar()) {\r\n                        parts.push(new LangArray(elements, source.absPos()))\r\n                        source.move()\r\n                        openDefinitions.arrays--\r\n                    } else {\r\n                        throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), source.currentChar(), ']')\r\n                    }\r\n                }\r\n                continue\r\n            }\r\n\r\n            // operators\r\n            if (leftOperatorExpected()) {\r\n                if (UniOperators.includes(c)) {\r\n                    parts.push(new UniOperator(c, source.absPos()))\r\n                    source.move()\r\n                    if (isSpace(source.currentChar())) throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), source.currentChar())\r\n                    continue\r\n                }\r\n            } else \r\n            if (rightOperatorExpected()) {\r\n                const next2 = source.remaining(2)\r\n                if (BiOperators.includes(next2)) {\r\n                    parts.push(new BiOperator(next2, source.absPos()))\r\n                    source.move(next2.length)\r\n                    continue\r\n                }\r\n                if (BiOperators.includes(c)) {\r\n                    parts.push(new BiOperator(c, source.absPos()))\r\n                    source.move()\r\n                    continue\r\n                }\r\n            }\r\n\r\n            if (parts.length && (!parts[parts.length - 1].isOperator || parts[parts.length - 1].isAccess)) \r\n                throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), source.currentChar())\r\n\r\n            const exp = this.parseMemberExpression(source)\r\n            parts.push(exp)\r\n        }\r\n\r\n        function leftOperatorExpected() {\r\n            return !parts.length || (parts[parts.length - 1].isOperator && !parts[parts.length - 1].isAccess)\r\n        }\r\n\r\n        function rightOperatorExpected() {\r\n            return parts.length && (!parts[parts.length - 1].isOperator || parts[parts.length - 1].isAccess)\r\n        }\r\n    }\r\n\r\n    parseMemberExpression(source) {\r\n        this._stepper()\r\n\r\n        let token = ''\r\n\r\n        for (; !source.finished(); source.move()) {\r\n            this._stepper()\r\n            \r\n            const c = source.currentChar()\r\n\r\n            // token ends\r\n            if (isExpressionSeparator(c)) {\r\n                if ('.' === c && /^(0|([1-9][0-9]*))$/.test(token) && /[0-9]/.test(source.next())) { // float number\r\n                    token += c\r\n                    continue\r\n                }\r\n                if (Keywords.TRUE.includes(token.toLowerCase())) {\r\n                    return new LangBoolean(true, source.absPos())\r\n                }\r\n                if (Keywords.FALSE.includes(token.toLowerCase())) {\r\n                    return new LangBoolean(false, source.absPos())\r\n                }\r\n                if (isNumeric(token)) {\r\n                    return new LangNumber(token.includes('.') ? parseFloat(token) : parseInt(token), source.absPos())\r\n                } \r\n                if (isIdentifier(token) || '$' === token) {\r\n                    return new VarReference(token, source.absPos())\r\n                }\r\n                throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), token)\r\n            }\r\n\r\n            if (isStringStarting(c)) {\r\n                source.move()\r\n                return new LangString(this.readString(source, c), source.absPos())\r\n            }\r\n\r\n            token += c\r\n        }\r\n    }\r\n\r\n    readList(source, groupingCloseChar) {\r\n        consumeSpaces(source)\r\n        if (groupingCloseChar === source.currentChar()) {\r\n            return []\r\n        } else {    // multiple params\r\n            const params = []\r\n            do {\r\n                const value = this.parseExpression(source, {}, groupingCloseChar)\r\n                params.push(value)\r\n\r\n                consumeSpaces(source)\r\n\r\n            } while(',' === source.currentChar() && !source.finished())\r\n\r\n            return params\r\n        }\r\n    }\r\n\r\n    readAttributes(source) {\r\n        consumeSpaces(source)\r\n        if ('}' === source.currentChar()) {\r\n            return {}\r\n        } else {    // multiple attributes\r\n            const attributes = {}\r\n            let first = true\r\n            do {\r\n                if (!first) {\r\n                    source.move()\r\n                }\r\n                first = false\r\n                consumeSpaces(source)\r\n\r\n                const name = this.readIdentifier(source)\r\n                if (attributes[name]) {\r\n                    throw new LangParseError(Errors.ATTRIBUTE_ALREADY_EXISTS, source.absPos(), name)\r\n                }\r\n                consumeSpaces(source)\r\n\r\n                if (':' !== source.currentChar()) {\r\n                    throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), ':', source.currentChar())\r\n                }\r\n                source.move()\r\n\r\n                const value = this.parseExpression(source, {}, '}')\r\n                attributes[name] = value\r\n\r\n                consumeSpaces(source)\r\n\r\n            } while(',' === source.currentChar() && !source.finished())\r\n\r\n            return attributes\r\n        }\r\n    }\r\n\r\n    parseWhile(source) {\r\n        const condCode = this.readUntilBodyOpens(source)\r\n        const cond = this.parseExpression(new Source(condCode, source.absPos() - condCode.length), {}, null)\r\n        const body = this.parseBody(source)\r\n        return new While(cond, body, source.absPos())\r\n    }\r\n\r\n    parseIf(source) {\r\n        const condCode = this.readUntilBodyOpens(source)\r\n        const cond = this.parseExpression(new Source(condCode, source.absPos() - condCode.length), {}, null)\r\n        const body = this.parseBody(source)\r\n        return new If(cond, body, null, source.absPos())\r\n    }\r\n\r\n    parseFunction(source) {\r\n        const args = this.readArguments(source)\r\n        const body = this.parseBody(source)\r\n        return new LangFunction(body, args, source.absPos())\r\n    }\r\n\r\n    readArguments(source) {\r\n        consumeSpaces(source)\r\n\r\n        if ('(' !== source.currentChar()) {\r\n            throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), '(', source.currentChar())\r\n        }       \r\n        source.move()\r\n        consumeSpaces(source) \r\n\r\n        const args = []\r\n        let first = true\r\n        while((',' === source.currentChar() || ')' !== source.currentChar()) && !source.finished()) {\r\n            if (!first) source.move()\r\n            first = false\r\n\r\n            const name = this.readIdentifier(source)\r\n            args.push(name)\r\n\r\n            consumeSpaces(source)\r\n        }\r\n\r\n        if (')' !== source.currentChar()) {\r\n            throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), ')', source.currentChar())\r\n        }\r\n        source.move()\r\n        return args\r\n    }\r\n\r\n    parseBody(source) {\r\n        consumeSpaces(source)\r\n\r\n        if ('{' !== source.currentChar()) {\r\n            throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), '{', source.currentChar())\r\n        }\r\n\r\n        source.move()\r\n        consumeSpaces(source)\r\n\r\n        let body = ''\r\n        let openQuotings = 0\r\n        while((openQuotings || '}' !== source.currentChar()) && !source.finished()) {\r\n            const c = source.currentChar()\r\n            body += c\r\n            source.move()\r\n\r\n            if ('{' === c) openQuotings++\r\n            if ('}' === c) openQuotings--\r\n        } \r\n\r\n        if ('}' !== source.currentChar()) {\r\n            throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), '}', source.currentChar())\r\n        }\r\n        source.move()\r\n\r\n        if (/^\\s*$/.test(body)) {\r\n            return new Block([new LangVoid(source.absPos())], source.absPos())\r\n        }\r\n\r\n        const block = this.parseBlock(new Source(body, source.absPos() - body.length))\r\n        return block\r\n    }\r\n    \r\n    readString(source, quoting) {\r\n        let token = ''\r\n        for (; !source.finished(); source.move()) {\r\n            const c = source.currentChar()\r\n\r\n            if (isStringEnding(c, quoting)) {\r\n                source.move()\r\n                return token\r\n            }\r\n            token += c\r\n        }\r\n        throw new LangParseError(Errors.UNEXPECTED_END, source.absPos())\r\n    }\r\n\r\n    readIdentifier(source) {\r\n        let token = ''\r\n        for (; !source.finished(); source.move()) {\r\n            const c = source.currentChar()\r\n            if (isSpace(c)) continue\r\n            if (!new RegExp(`^${RE_IDENTIFIER}$`).test(token + c)) break                \r\n            token += c\r\n        }\r\n        if (token) return token\r\n        throw new LangParseError(Errors.EXPECTED_IDENTIFIER, source.absPos())\r\n    }\r\n\r\n    readUntilBodyOpens(source) {\r\n        let curlies = 0\r\n        let quotations = 0\r\n        let token = ''\r\n        for (; !source.finished(); source.move()) {\r\n            const c = source.currentChar()\r\n            if (isStringStarting(c)) {\r\n                token += this.readString(source, c)\r\n                continue\r\n            }\r\n            if ('(' === c) quotations++\r\n            else\r\n            if (')' === c) quotations--\r\n            else\r\n            if ('{' === c) {\r\n                if (!curlies && !quotations) break\r\n                curlies++\r\n            } else \r\n            if ('}' === c) {\r\n                curlies--\r\n                if (curlies < 0) throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), c)\r\n            }\r\n            token += c\r\n        }\r\n        if (token) return token\r\n    }\r\n\r\n    _stepper() {\r\n        this.steps++\r\n        if (this.steps > this.maxSteps) throw new LangParseError(Errors.PARSER_STEPS_EXCEEDED, source.absPos())\r\n    }\r\n}\r\n\r\nfunction consumeSpaces(source, stopAtNewLine = false) {\r\n    while (!source.finished() && /\\s/.test(source.currentChar()) && (!stopAtNewLine || '\\n' !== source.currentChar())) source.move()\r\n}\r\n\r\nfunction consumeUntil(source, untilChar) {\r\n    const re = new RegExp(untilChar)\r\n    while (!source.finished() && !re.test(source.currentChar())) source.move()\r\n}\r\n\r\nfunction isNumeric(str) {\r\n    return !isNaN(str) && !isNaN(parseFloat(str))\r\n}\r\n\r\nfunction isKeyword(str) {\r\n    str = str.toLowerCase()\r\n    return Object.values(Keywords).some(k => k.includes(str)) ||  WhileKeywords.includes(str) || IfKeywords.includes(str)\r\n}\r\n\r\nfunction isSpace(c) {\r\n    return '\\n' !== c && /\\s+/g.test(c)\r\n}\r\n\r\nfunction isExpressionSeparator(c) {\r\n    return isSpace(c) || isStatementSeparator(c) \r\n        || '(' === c || ')' === c || '[' === c || ']' === c || '{' === c || '}' === c \r\n        || '.' === c || ',' === c\r\n        || BiOperators.some(op => op.startsWith(c)) || UniOperators.some(op => op.startsWith(c))\r\n}\r\n\r\nfunction isStatementSeparator(c) {\r\n    return '\\n' === c || ';' === c\r\n}\r\n\r\nfunction isStringStarting(c) {\r\n    return c === '\"' || c === '“' || c === '”' || c === \"'\"\r\n}\r\n\r\nfunction isStringEnding(c, quoting) {\r\n    return quoting === c || (c === '”' && quoting === '“')\r\n}\r\n\r\nfunction isIdentifier(token) {\r\n    return new RegExp(`^${RE_IDENTIFIER}$`).test(token)\r\n}\r\n\r\nfunction isFunctionDef(remaining) {\r\n    return new RegExp(`^${RE_FUNCTION}`).test(remaining)\r\n}\r\n\r\nfunction isWhileDef(remaining) {\r\n    return WhileKeywords.some(k => new RegExp(`^\\\\s*${k}\\\\s(.*)\\\\s{`).test(remaining)) \r\n}\r\n\r\nfunction isIfDef(remaining) {\r\n    return IfKeywords.some(k => new RegExp(`^\\\\s*${k}\\\\s(.*)\\\\s{`).test(remaining)) \r\n}\r\n\r\nfunction isElseDef(remaining) {\r\n    return ElseKeywords.some(k => new RegExp(`^\\\\s*${k}\\\\s+{`).test(remaining)) \r\n}\r\n\r\nfunction isComment(remaining) {\r\n    return new RegExp('^//').test(remaining)\r\n}\r\n\r\nmodule.exports = Parser","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/ludolfc.js\");\n",""],"names":[],"sourceRoot":""}