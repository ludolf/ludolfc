{"version":3,"file":"ludolfc.js","mappings":"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","sources":["webpack://ludolfc/webpack/universalModuleDefinition","webpack://ludolfc/./src/interpreter.js","webpack://ludolfc/./src/lang.js","webpack://ludolfc/./src/ludolfc.js","webpack://ludolfc/./src/parser.js","webpack://ludolfc/webpack/bootstrap","webpack://ludolfc/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ludolfc\"] = factory();\n\telse\n\t\troot[\"ludolfc\"] = factory();\n})(this, () => {\nreturn ","const { \r\n    Types,\r\n    Errors,\r\n    Interruptions,\r\n    InterpretError: LangInterpretError,\r\n    Interrupt: LangInterrupt,\r\n    Void: LangVoid } = require('./lang')\r\n    \r\nclass Interpret {\r\n    constructor(imports = {}, controls, maxSteps = 100000) {\r\n        this.imports = imports\r\n        this.stepper = new ExecutionStepper(maxSteps, controls && controls.isInterrupted) // to prevent infinite loops        \r\n    }\r\n\r\n    async execute(ast) {\r\n        this.variables = new VariablesScope(this.imports)\r\n        this.stepper.reset()\r\n        return await this.executeBlock(ast, false)\r\n    }\r\n\r\n    async executeBlock(block, newScope = true) {        \r\n        if (newScope) this.variables = this.variables.pushScope()\r\n        let result\r\n        for (let stm of block.statements) {\r\n            result = await this.executeStatement(stm)\r\n        }\r\n        if (newScope) this.variables = this.variables.popScope()\r\n        return result ? result : new LangVoid()\r\n    }\r\n\r\n    async executeStatement(stm) {\r\n        this.stepper.step(stm.source)\r\n        return stm.isExpression ? await this.executeExpression(stm) :\r\n               stm.isAssignment ? await this.executeAssignment(stm) :\r\n               stm.isWhile ? await this.executeWhile(stm) :\r\n               stm.isIf ? await this.executeIf(stm) : \r\n               stm\r\n    }\r\n\r\n    async executeExpression(expression, assignNewValue = null) {\r\n        this.stepper.step(expression.source)\r\n        if (!expression.parts) throw new LangInterpretError(Errors.EMPTY_EXPRESSION, expression.source)\r\n        let parts = [...expression.parts]\r\n        return await this.executeExpressionParts(parts, assignNewValue)\r\n    }\r\n\r\n    async executeExpressionParts(parts, assignNewValue = null) {\r\n        // logical operators short circuit\r\n        const executeShortCircuitExpressionParts = async (op, parts, assignNewValue, shouldShortCircuit) => {\r\n            const index = findFirstOp(op)\r\n            if (index) {\r\n                const left = await this.executeExpressionParts(parts.slice(0, index), assignNewValue)\r\n                if (left.type !== Types.BOOLEAN) throw new LangInterpretError(Errors.WRONG_BI_OPERATOR_SUBJECTS, left.source)\r\n                if (shouldShortCircuit(left.value)) return left\r\n                const right = await this.executeExpressionParts(parts.slice(index + 1), assignNewValue)\r\n                if (right.type !== Types.BOOLEAN) throw new LangInterpretError(Errors.WRONG_BI_OPERATOR_SUBJECTS, right.source)\r\n                return right\r\n            }\r\n        }\r\n        const expOr = await executeShortCircuitExpressionParts('|', parts, assignNewValue, value => value)\r\n        if (expOr) return expOr\r\n        const expAnd = await executeShortCircuitExpressionParts('&', parts, assignNewValue, value => !value)\r\n        if (expAnd) return expAnd\r\n\r\n        // left to right by precendence\r\n        let index, assignApplied = false\r\n        while ((index = findNextOp()) > -1) {\r\n            const op = parts[index]\r\n\r\n            if (assignNewValue && !op.isObjectAccess && !op.isArrayAccess) throw new LangInterpretError(Errors.ACCESS_OPERATOR_EXPECTED, op.source)\r\n\r\n            try {\r\n                if (op.isUni) {\r\n                    const a = await this.executeExpressionPart(parts[index + 1])\r\n                    if (!a.type) throw new LangInterpretError(Errors.WRONG_UNI_OPERATOR_SUBJECT, op.source)\r\n                    parts[index] = op.apply(a)\r\n                    parts = removeElementAt(parts, index + 1)\r\n                } else\r\n                if (op.isBi) {\r\n                    const a = await this.executeExpressionPart(parts[index - 1])\r\n                    const b = await this.executeExpressionPart(parts[index + 1])\r\n                    if (!a.type || !b.type) throw new LangInterpretError(Errors.WRONG_BI_OPERATOR_SUBJECTS, op.source)\r\n                    if (a.type !== b.type && !(op.isAddition && Types.STRING === a.type && b.isPrimitive)) throw new LangInterpretError(Errors.UNMATCHING_BI_OPERATOR_SUBJECTS, op.source)\r\n                    parts[index] = op.apply(a, b)\r\n                    parts = removeElementAt(parts, index - 1, index + 1)\r\n                } else\r\n                if (op.isArrayAccess) {\r\n                    const a = await this.executeExpressionPart(parts[index - 1])\r\n                    if (Types.ARRAY !== a.type) throw new LangInterpretError(Errors.EXPECTED_ARRAY, op.source)\r\n                    if (assignNewValue && a.protectedAttributes()) throw new LangInterpretError(Errors.PROTECTED_FROM_MODIFICATION, op.source)\r\n                    const indexes = await Promise.all(op.indexes.map(i => this.executeExpressionPart(i)))\r\n                    parts[index] = op.apply(a, indexes, (assignNewValue && isLastOperator()) ? assignNewValue : null)\r\n                    if (!parts[index]) throw new LangInterpretError(Errors.ATTRIBUTE_NOT_FOUND, op.source)\r\n                    parts = removeElementAt(parts, index - 1)\r\n                    assignApplied = true\r\n                } else\r\n                if (op.isObjectAccess) {\r\n                    const o = await this.executeExpressionPart(parts[index - 1])\r\n                    if (!o.isObject && !o.isFunction) throw new LangInterpretError(Errors.EXPECTED_OBJECT, op.source)\r\n                    if (assignNewValue && o.protectedAttributes()) throw new LangInterpretError(Errors.PROTECTED_FROM_MODIFICATION, op.source)\r\n                    parts[index] = op.apply(o, (assignNewValue && isLastOperator()) ? assignNewValue : null)\r\n                    if (!parts[index]) throw new LangInterpretError(Errors.ATTRIBUTE_NOT_FOUND, op.source)\r\n                    parts = removeElementAt(parts, index - 1)\r\n                    assignApplied = true\r\n                } else \r\n                if (op.isCall) {\r\n                    parts[index] = new FunctionExecution(parts[index - 1], op.params)  // to prevent immediate execution\r\n                    parts = removeElementAt(parts, index - 1)\r\n                }\r\n                else throw new LangInterpretError(Errors.UNKNOWN_OPERATOR, op.source)\r\n\r\n            } catch (e) {   // LangError could be raised from applying the operator in lang.js\r\n                if (e.isLangError) {\r\n                    if (!e.isInterpretError) throw new LangInterpretError(e.id, op.source, e.arg1, e.arg2)\r\n                } else {\r\n                    throw new LangInterpretError(Errors.UNKNOWN_ERROR, op.source, e)\r\n                }\r\n                throw e\r\n            }\r\n        }\r\n\r\n        if (assignNewValue && !assignApplied) throw new LangInterpretError(Errors.ACCESS_OPERATOR_EXPECTED, parts[0].source)\r\n\r\n        return await this.executeExpressionPart(parts[0]) // parts are reduced to a single result\r\n\r\n        function findNextOp() { // returns an index of the next part\r\n            let index = -1\r\n            let maxPrecedence = Number.MIN_SAFE_INTEGER\r\n            for (let i = 0; i < parts.length; i++) {\r\n                const op = parts[i]\r\n                if (!op.isOperator) continue\r\n                if (maxPrecedence < op.precedence || (op.isUni && maxPrecedence === op.precedence)) {\r\n                    index = i\r\n                    maxPrecedence = op.precedence\r\n                }\r\n            }\r\n            return index\r\n        }\r\n\r\n        function removeElementAt(arr, ...indexes) {\r\n            return arr.filter((_, i) => !indexes.includes(i))\r\n        }\r\n\r\n        function isLastOperator() {\r\n            return parts.length === 2\r\n        }\r\n\r\n        function findFirstOp(op) {\r\n            for (let i = 0; i < parts.length; i++)\r\n                if (parts[i].isBi && parts[i].op === op) return i\r\n        }\r\n    }\r\n\r\n    async executeExpressionPart(expressionPart) {\r\n        this.stepper.step(expressionPart.source)\r\n        \r\n        if (expressionPart.isReference) {\r\n            if (!this.variables.hasVariable(expressionPart.varName)) throw new LangInterpretError(Errors.UNREFERENCED_VARIABLE, expressionPart.source - expressionPart.varName.length, expressionPart.varName)\r\n            return this.variables.getVariable(expressionPart.varName)\r\n        }\r\n        if (expressionPart.isFunctionExecution) {\r\n            const func = await this.executeExpressionPart(expressionPart.funcExp)\r\n            const params = await Promise.all(expressionPart.params.map(p => this.executeExpressionPart(p)))\r\n            return await this.executeFunctionCall(func, params)\r\n        }\r\n        if (expressionPart.isExpression) {\r\n            return await this.executeExpression(expressionPart)\r\n        }\r\n        if (Types.ARRAY === expressionPart.type) {\r\n            const arr = expressionPart.value\r\n            for (let i = 0; i < arr.length; i++) {\r\n                arr[i] = await this.executeExpressionPart(arr[i])\r\n            }\r\n        } else\r\n        if (Types.OBJECT === expressionPart.type) {\r\n            const obj = expressionPart.value\r\n            for (let k of Object.keys(obj)) {\r\n                obj[k] = await this.executeExpressionPart(obj[k])\r\n                if (obj[k].isObject || obj[k].isFunction) obj[k].parent = expressionPart\r\n            }\r\n        }\r\n        if (expressionPart.isFunction && !expressionPart.scope) {\r\n            expressionPart.scope = this.variables.copy()            \r\n        }\r\n        return expressionPart\r\n    }\r\n\r\n    async executeFunctionCall(f, params) {\r\n        if (f.isNative) {\r\n            const result = await f.call(...params)\r\n            return !result ? new LangVoid() : result\r\n        }\r\n\r\n        if ((!params && f.args) || params.length !== f.args.length) throw new LangInterpretError(Errors.FUNC_ARGUMENTS_MISHMASH, f.source)\r\n        // scoped variables\r\n        let i = 0\r\n        const variablesBak = this.variables\r\n        this.variables = f.scope.pushScope()\r\n        for (let arg of f.args) {\r\n            this.variables.setVariable(arg, params[i++], true)\r\n        }\r\n        if (f.parent) {\r\n            // cache \"this\" object into variable $\r\n            this.variables.setVariable('$', f.parent, true)\r\n        }\r\n        \r\n        try {\r\n            const body = f.body.copy()\r\n            const result = await this.executeBlock(body, false)\r\n            return result\r\n\r\n        } finally {  // clean up variables\r\n            this.variables.popScope()\r\n            this.variables = variablesBak\r\n        }\r\n    }\r\n\r\n    async executeAssignment(assignment) {\r\n        if (!assignment.left || !assignment.right) {\r\n            throw new LangInterpretError(Errors.WRONG_ASSIGNMENT, assignment.source)\r\n        }\r\n        const value = await this.executeExpressionPart(assignment.right)        \r\n        // variable assignment\r\n        if (assignment.left.isVariable) {\r\n            const variable = this.variables.getVariable(assignment.left.name)\r\n            if (variable.protected && variable.protected()) throw new LangInterpretError(Errors.PROTECTED_FROM_MODIFICATION, assignment.left.source)\r\n            this.variables.setVariable(assignment.left.name, value)\r\n        } else\r\n        // object attribute or array element assignment\r\n        if (assignment.left.isExpression) {\r\n            await this.executeExpression(assignment.left, value)\r\n        }\r\n        else throw new LangInterpretError(Errors.WRONG_ASSIGNEE_TYPE)\r\n    }\r\n\r\n    async executeWhile(whileStm) {\r\n        if (!whileStm.condition || !whileStm.condition.isExpression) throw new LangInterpretError(Errors.WRONG_CONDITION, whileStm.source)\r\n        while (true) {\r\n            const cond = await this.executeExpressionPart(whileStm.condition)\r\n            if (cond.type !== Types.BOOLEAN) throw new LangInterpretError(Errors.WRONG_CONDITION_VALUE, cond.source)\r\n            if (cond.value) await this.executeBlock(whileStm.body.copy())\r\n            else break\r\n        } \r\n    }\r\n\r\n    async executeIf(ifStm) {\r\n        if (!ifStm.condition || !ifStm.condition.isExpression) throw new LangInterpretError(Errors.WRONG_CONDITION, ifStm.source)\r\n        const cond = await this.executeExpressionPart(ifStm.condition)\r\n        if (cond.type !== Types.BOOLEAN) throw new LangInterpretError(Errors.WRONG_CONDITION_VALUE, cond.source)\r\n        if (cond.value) await this.executeBlock(ifStm.body)\r\n        else if (ifStm.elseBody) await this.executeBlock(ifStm.elseBody)\r\n    }\r\n}\r\n\r\nclass VariablesScope {\r\n    constructor(imports = {}) {\r\n        this.variables = new Map()\r\n        this.parent = null\r\n        if (imports) Object.entries(imports).forEach(([k,v]) => this.variables.set(k, v))\r\n    }\r\n\r\n    hasVariable(name) {\r\n        if (this.variables.has(name)) return true\r\n        if (this.variables.has('$')) {\r\n            const self = this.variables.get('$')\r\n            if (self.hasAttribute(name)) return true\r\n        }\r\n        if (this.parent) return this.parent.hasVariable(name)\r\n        return false\r\n    }\r\n\r\n    getVariable(name) {\r\n        if (this.variables.has(name)) return this.variables.get(name)\r\n        if (this.variables.has('$')) {\r\n            const self = this.variables.get('$')\r\n            if (self.hasAttribute(name)) return self.attribute(name)\r\n        }\r\n        if (this.parent) return this.parent.getVariable(name)\r\n        return false\r\n    }\r\n\r\n    setVariable(name, value, scoped = false) {\r\n        if (scoped) {\r\n            this.variables.set(name, value)\r\n            return\r\n        }\r\n        let found = false\r\n        let scope = this\r\n        do {\r\n            if (scope.variables.has(name)) {\r\n                scope.variables.set(name, value)\r\n                found = true\r\n            }\r\n            scope = scope.parent\r\n        } while (!found && scope)\r\n        \r\n        if (!found) {\r\n            this.variables.set(name, value)\r\n        }\r\n    }\r\n\r\n    pushScope() {\r\n        const newScope = new VariablesScope()\r\n        newScope.parent = this\r\n        return newScope\r\n    }\r\n\r\n    popScope() {\r\n        const parent = this.parent\r\n        this.parent = null\r\n        return parent\r\n    }\r\n\r\n    copy() {\r\n        const newScope = new VariablesScope(this.imports)\r\n        newScope.variables = this.variables\r\n        newScope.parent = this.parent\r\n        return newScope\r\n    }\r\n}\r\n\r\n// wrapper over a function call (func and params are not resolved yet)\r\nclass FunctionExecution {\r\n    constructor(funcExp, params) {\r\n        this.funcExp = funcExp\r\n        this.params = params\r\n        this.isFunctionExecution = true\r\n    }\r\n}\r\n\r\nclass ExecutionStepper {\r\n    constructor(maxSteps, isInterruptedFn) {\r\n        this.maxSteps = maxSteps\r\n        this.isInterruptedFn = isInterruptedFn\r\n        this.steps = 0        \r\n    }\r\n\r\n    step(source) {\r\n        if (this.isInterruptedFn && this.isInterruptedFn()) throw new LangInterrupt(Interruptions.USER_SUSSPEND)\r\n        this.steps++\r\n        if (this.steps > this.maxSteps) throw new LangInterpretError(Errors.EXECUTION_STEPS_EXCEEDED, source)\r\n    }\r\n\r\n    reset(maxSteps = null) {\r\n        this.steps = 0\r\n        if (maxSteps) this.maxSteps = maxSteps\r\n    }\r\n}\r\n\r\nmodule.exports = Interpret","const Keywords = {\r\n    TRUE: ['true', 'pravda', 'wahr'],\r\n    FALSE: ['false', 'nepravda', 'falsch'],\r\n    IF: ['if', 'pokud', 'falls'],\r\n    ELSE: ['else', 'jinak', 'sonst'],\r\n    WHILE: ['while', 'dokud', 'solange'],\r\n}\r\n\r\nconst FeatureLocalizations = {\r\n    SIZE: ['size', 'velikost', 'gre'],\r\n}\r\n\r\nconst Errors = {\r\n    INVALID_UNI_OPERATOR: 'INVALID_UNI_OPERATOR',\r\n    INVALID_BI_OPERATOR: 'INVALID_BI_OPERATOR',\r\n    UNEXPECTED_END: 'UNEXPECTED_END',\r\n    UNEXPECTED_SYMBOL: 'UNEXPECTED_SYMBOL',\r\n    EXPECTED_SYMBOL: 'EXPECTED_SYMBOL',\r\n    UNREFERENCED_VARIABLE: 'UNREFERENCED_VARIABLE',\r\n    UNEXPECTED_KEYWORD: 'UNEXPECTED_KEYWORD',\r\n    INVALID_IDENTIFIER: 'INVALID_IDENTIFIER',\r\n    UNEVEN_OPERATORS: 'UNEVEN_OPERATORS',\r\n    EXPECTED_FUNCTION: 'EXPECTED_FUNCTION',\r\n    EXPECTED_STATEMENT_END: 'EXPECTED_STATEMENT_END',\r\n    ARRAY_INDEX_NOT_NUMBER: 'ARRAY_INDEX_NOT_NUMBER',\r\n    ARRAY_INDEX_MISSING: 'ARRAY_INDEX_MISSING',\r\n    ARRAY_INDEX_OUT_BOUNDS: 'ARRAY_INDEX_OUT_BOUNDS',\r\n    FUNC_ARGUMENTS_MISHMASH: 'FUNC_ARGUMENTS_MISHMASH',\r\n    ATTRIBUTE_ALREADY_EXISTS: 'ATTRIBUTE_ALREADY_EXISTS',\r\n    ATTRIBUTE_NOT_FOUND: 'ATTRIBUTE_NOT_FOUND',\r\n    ELEMENT_NOT_FOUND: 'ELEMENT_NOT_FOUND',\r\n    EMPTY_EXPRESSION: 'EMPTY_EXPRESSION',\r\n    UNKNOWN_OPERATOR: 'UNKNOWN_OPERATOR',\r\n    OPERATOR_NOT_APPLICABLE: 'OPERATOR_NOT_APPLICABLE',\r\n    ACCESS_OPERATOR_EXPECTED: 'ACCESS_OPERATOR_EXPECTED',\r\n    WRONG_UNI_OPERATOR_SUBJECT: 'WRONG_UNI_OPERATOR_SUBJECT',\r\n    WRONG_BI_OPERATOR_SUBJECTS: 'WRONG_BI_OPERATOR_SUBJECTS',\r\n    UNMATCHING_BI_OPERATOR_SUBJECTS: 'UNMATCHING_BI_OPERATOR_SUBJECTS',\r\n    EXPECTED_ARRAY: 'EXPECTED_ARRAY',\r\n    EXPECTED_OBJECT: 'EXPECTED_OBJECT',\r\n    EXPECTED_IDENTIFIER: 'EXPECTED_IDENTIFIER',\r\n    WRONG_ASSIGNMENT: 'WRONG_ASSIGNMENT',\r\n    WRONG_ASSIGNEE_TYPE: 'WRONG_ASSIGNEE_TYPE',\r\n    READONLY_ATTRIBUTE: 'READONLY_ATTRIBUTE',\r\n    WRONG_CONDITION: 'WRONG_CONDITION',\r\n    WRONG_CONDITION_VALUE: 'WRONG_CONDITION_VALUE',\r\n    EXECUTION_STEPS_EXCEEDED: 'EXECUTION_STEPS_EXCEEDED',\r\n    PARSER_STEPS_EXCEEDED: 'PARSER_STEPS_EXCEEDED',\r\n    PROTECTED_FROM_MODIFICATION: 'PROTECTED_FROM_MODIFICATION',\r\n    DIVISION_BY_ZERO: 'DIVISION_BY_ZERO',\r\n    UNKNOWN_ERROR: 'UNKNOWN_ERROR',\r\n}\r\n\r\nconst Types = {\r\n    NUMBER: 'NUMBER',\r\n    BOOLEAN: 'BOOLEAN',\r\n    STRING: 'STRING',\r\n    ARRAY: 'ARRAY',\r\n    OBJECT: 'OBJECT',\r\n    FUNCTION: 'FUNCTION',\r\n    VOID: 'VOID',\r\n}\r\n\r\nconst Interruptions = {\r\n    USER_SUSSPEND: 'USER_SUSSPEND',\r\n}\r\n\r\nclass LangInterrupt {\r\n    constructor(id) {\r\n        this.id = id\r\n        this.isLangInterruption = true\r\n    }\r\n}\r\n\r\nclass LangError extends Error {\r\n    constructor(id, pos, arg1, arg2) {\r\n        super(id)\r\n        this.details = `${arg1 ? `\"${arg1}\"` : ''} ${arg2 ? `\"${arg2}\"` : ''}`\r\n        this.message = `${id} ${this.details}`\r\n        this.id = id\r\n        this.arg1 = arg1\r\n        this.arg2 = arg2\r\n        this.position = pos\r\n        this.isLangError = true\r\n    }\r\n}\r\n\r\nclass LangParseError extends LangError {\r\n    constructor(id, pos, arg1, arg2) {\r\n        super(id, pos, arg1, arg2)\r\n        this.isParseError = true\r\n    }\r\n}\r\n\r\nclass LangInterpretError extends LangError {\r\n    constructor(id, pos, arg1, arg2) {\r\n        super(id, pos, arg1, arg2)\r\n        this.isInterpretError = true\r\n    }\r\n}\r\n\r\nclass Block {\r\n    constructor(statements, source) {\r\n        this.statements = statements\r\n        this.source = source\r\n    }\r\n    copy() {\r\n        return new Block(this.statements.map(s => s.copy()), this.source)\r\n    }\r\n}\r\n\r\nclass Statement {\r\n    constructor(source) {\r\n        this.isExpression = false\r\n        this.isAssignment = false\r\n        this.isWhile = false\r\n        this.isIf = false\r\n        this.source = source\r\n    }\r\n    copy() {\r\n        return this // immutable\r\n    }\r\n}\r\n\r\nclass Assignment extends Statement {\r\n    constructor(left, right, source) {\r\n        super(source)\r\n        this.isAssignment = true\r\n        this.left = left\r\n        this.right = right\r\n    }\r\n    copy() {\r\n        return new Assignment(this.left.copy(), this.right.copy(), this.source)\r\n    }\r\n}\r\n\r\nclass While extends Statement {\r\n    constructor(condition, body, source) {\r\n        super(source)\r\n        this.isWhile = true\r\n        this.condition = condition\r\n        this.body = body\r\n    }\r\n    copy() {\r\n        return new While(this.condition.copy(), this.body.copy(), this.source)\r\n    }\r\n}\r\n\r\nclass If extends Statement {\r\n    constructor(condition, body, bodyElse, source) {\r\n        super(source)\r\n        this.isIf = true\r\n        this.condition = condition\r\n        this.body = body\r\n        this.elseBody = bodyElse\r\n    }\r\n    copy() {\r\n        return new If(this.condition.copy(), this.body.copy(),this.elseBody?.copy(), this.source)\r\n    }\r\n}\r\n\r\nclass Expression extends Statement {\r\n    constructor(parts, source) {\r\n        super(source)\r\n        this.isExpression = true\r\n        this.parts = parts\r\n    }\r\n    copy() {\r\n        return new Expression(this.parts.map(p => p.copy()), this.source)\r\n    }\r\n}\r\n\r\nclass Variable {\r\n    constructor(name, source) {\r\n        this.isVariable = true\r\n        this.name = name\r\n        this.source = source\r\n    }\r\n    copy() {\r\n        return this // immutable\r\n    }\r\n}\r\n\r\nclass Operator {\r\n    constructor(op, precedence = -1) {\r\n        this.op = op\r\n        this.isOperator = true\r\n        this.precedence = precedence\r\n    }\r\n    copy() {\r\n        return this // immutable\r\n    }\r\n}\r\n\r\nclass UniOperator extends Operator {\r\n    constructor(op, source) {\r\n        super(op)\r\n        this.isUni = true\r\n        this.precedence = this.getPrecedence()\r\n        this.source = source\r\n    }\r\n    apply(a) {\r\n        const fn = getFn(this.op)\r\n        if (!fn || !fn.call) throw new LangError(Errors.OPERATOR_NOT_APPLICABLE, null, this.op)\r\n        return fn.call()\r\n\r\n        function getFn(op) {\r\n            switch (op) {\r\n                case '!': \r\n                case '-': return a.neg\r\n                default: throw new LangError(Errors.INVALID_UNI_OPERATOR, null, this.op)\r\n            }\r\n        }\r\n    }\r\n    getPrecedence() { // based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n        switch (this.op) {\r\n            case '!':\r\n            case '-': return 14\r\n            default: -1\r\n        }\r\n    }\r\n}\r\n\r\nclass BiOperator extends Operator {\r\n    constructor(op, source) {\r\n        super(op)\r\n        this.isBi = true\r\n        this.precedence = this.getPrecedence()\r\n        this.isAddition = '+' === op\r\n        this.source = source\r\n    }\r\n    apply(a, b) {\r\n        const fn = getFn(this.op)\r\n        if (!fn || !fn.call) {\r\n            if ('=' === this.op) return new LangBoolean(false)\r\n            throw new LangError(Errors.OPERATOR_NOT_APPLICABLE, null, this.op)\r\n        }\r\n        if ('/' === this.op && Types.NUMBER === b.type && b.value === 0) {\r\n            throw new LangError(Errors.DIVISION_BY_ZERO, null, this.op)\r\n        }\r\n        return fn.call(b)\r\n\r\n        function getFn(op) {\r\n            switch (op) {\r\n                case '*': return a.mult\r\n                case '/': return a.div\r\n                case '%': return a.mod\r\n                case '+': return a.plus\r\n                case '-': return a.minus\r\n                case '<': return a.lt\r\n                case '<=': return a.le\r\n                case '>': return a.gt\r\n                case '>=': return a.ge\r\n                case '=': return a.eq\r\n                case '!=': return a.ne\r\n                case '&': return a.and\r\n                case '|': return a.or\r\n                default: throw new LangError(Errors.INVALID_BI_OPERATOR, null, this.op)\r\n            }\r\n        }\r\n    }\r\n    getPrecedence() { // based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n        switch (this.op) {\r\n            case '*':\r\n            case '/':\r\n            case '%': return 12\r\n            case '+': \r\n            case '-': return 11\r\n            case '<': \r\n            case '<=':\r\n            case '>':\r\n            case '>=': return 9\r\n            case '=': \r\n            case '!=': return 8\r\n            case '&': return 4\r\n            case '|': return 3\r\n            default: -1\r\n        }\r\n    }\r\n}\r\n\r\nclass ArrayAccess extends Operator {\r\n    constructor(indexes, source) {\r\n        super('[]', 17)\r\n        this.isAccess = true\r\n        this.isArrayAccess = true\r\n        this.indexes = indexes\r\n        this.source = source\r\n    }\r\n    apply(a, indexes, newValue) { // indexes are resolved, but this.indexes are AST (expressions)\r\n        return a.element(indexes, newValue)\r\n    }\r\n}\r\n\r\nclass ObjectAccess extends Operator {\r\n    constructor(attrName, source) {\r\n        super('.', 17)\r\n        this.isAccess = true\r\n        this.isObjectAccess = true\r\n        this.attrName = attrName\r\n        this.source = source\r\n    }\r\n    apply(o, newValue) {\r\n        return o.attribute(this.attrName, newValue)\r\n    }\r\n}\r\n\r\nclass FunctionCall extends Operator {\r\n    constructor(params, source) {\r\n        super('()', 17)\r\n        this.isAccess = true\r\n        this.isCall = true\r\n        this.params = params\r\n        this.source = source\r\n    }\r\n}\r\n\r\nclass VarReference {\r\n    constructor(varName, source) {\r\n        this.isReference = true\r\n        this.varName = varName\r\n        this.source = source\r\n    }\r\n    copy() {\r\n        return this // immutable\r\n    }\r\n}\r\n\r\nclass LangObject {\r\n    constructor(obj, source, type = Types.OBJECT) {\r\n        this.value = obj\r\n        this.type = type\r\n        this.isObject = true\r\n        this.parent = null\r\n        this.source = source\r\n\r\n        this.eq = new LangNativeFunction(x => new LangBoolean(areObjectsEqual(this, x)))\r\n        this.ne = new LangNativeFunction(x => new LangBoolean(!(this.eq.call(x).value)))\r\n    }\r\n    attribute(name, newValue) {\r\n        const value = this[name] ? this[name] : this.value[name] // explicit attrs have priority over native ones\r\n        if (newValue && this.value[name]) this.value[name] = newValue\r\n        if (value) return value\r\n        if (this.parent) return this.parent.attribute(name)\r\n    }\r\n    hasAttribute(name) {\r\n        const hasValue = this[name] || this.value[name]\r\n        return hasValue || (this.parent && this.parent.hasAttribute(name))\r\n    }\r\n    protected() {\r\n        return this.isProtected || (this.parent && this.parent.protected())\r\n    }\r\n    protectedAttributes() {\r\n        return this.protected()\r\n    }\r\n    copy() {\r\n        const valueCopy = {}\r\n        Object.keys(this.value).forEach(k => valueCopy[k] = this.value[k].copy())\r\n        return new LangObject(valueCopy, this.source)\r\n    }\r\n}\r\n\r\nclass LangValueObject extends LangObject {\r\n    constructor(value, source, type) {\r\n        super(value, source, type)\r\n\r\n        this.eq = new LangNativeFunction(x => new LangBoolean(this.value === x.value))\r\n        this.ne = new LangNativeFunction(x => new LangBoolean(this.value !== x.value))\r\n    }\r\n    copy() {\r\n        return this // immutable\r\n    }\r\n}\r\n\r\nclass LangNumber extends LangValueObject {\r\n    constructor(value, source) {\r\n        super(value, source, Types.NUMBER)\r\n        this.isPrimitive = true\r\n        \r\n        this.mult = new LangNativeFunction(x => new LangNumber(this.value * x.value))\r\n        this.div = new LangNativeFunction(x => new LangNumber(this.value / x.value))\r\n        this.mod = new LangNativeFunction(x => new LangNumber(this.value % x.value))\r\n        this.plus = new LangNativeFunction(x => new LangNumber(this.value + x.value))\r\n        this.minus = new LangNativeFunction(x => new LangNumber(this.value - x.value))\r\n        this.lt = new LangNativeFunction(x => new LangBoolean(this.value < x.value))\r\n        this.le = new LangNativeFunction(x => new LangBoolean(this.value <= x.value))\r\n        this.gt = new LangNativeFunction(x => new LangBoolean(this.value > x.value))\r\n        this.ge = new LangNativeFunction(x => new LangBoolean(this.value >= x.value))\r\n        this.neg = new LangNativeFunction(() => new LangNumber(-this.value))\r\n        this.sum = new LangNativeFunction((...x) => new LangNumber(x.reduce((a,c) => a + c.value, this.value)))\r\n        this.round = new LangNativeFunction(() => new LangNumber(Math.round(this.value)))\r\n        this.floor = new LangNativeFunction(() => new LangNumber(Math.floor(this.value)))\r\n        this.ceil = new LangNativeFunction(() => new LangNumber(Math.ceil(this.value)))\r\n    }\r\n}\r\n\r\nclass LangString extends LangValueObject {\r\n    constructor(value, source) {\r\n        super(value, source, Types.STRING)\r\n        this.isPrimitive = true\r\n\r\n        this.concat = new LangNativeFunction(x => new LangString(this.value + x.value))\r\n        this.length = new LangNativeFunction(() => new LangNumber(this.value.length))\r\n        this.charAt = new LangNativeFunction(i => new LangString(this.value.charAt(i.value)))\r\n        this.sub = new LangNativeFunction((i, j) => {\r\n            if (i.value > this.value.length - 1 || i.value < 0 || (j && j.value <= i.value) || (j && j.value > this.value.length)) return new LangString('')\r\n            return new LangString(this.value.substring(i.value, j ? j.value : this.value.length))\r\n        })\r\n        \r\n        this.plus = this.concat\r\n        for (let s of FeatureLocalizations.SIZE) this[s] = new LangNumber(this.value.length)\r\n    }\r\n}\r\n\r\nclass LangBoolean extends LangValueObject {\r\n    constructor(value, source) {\r\n        super(value, source, Types.BOOLEAN)\r\n        this.isPrimitive = true\r\n\r\n        this.and = new LangNativeFunction(x => new LangBoolean(this.value && x.value))\r\n        this.or = new LangNativeFunction(x => new LangBoolean(this.value || x.value))\r\n        this.xor = new LangNativeFunction(x => new LangBoolean(this.value ? !x.value : x.value))\r\n        this.nand = new LangNativeFunction(x => new LangBoolean(!(this.value && x.value)))\r\n        this.neg = new LangNativeFunction(() => new LangBoolean(!this.value))\r\n\r\n        this.mult = this.and\r\n        this.plus = this.or\r\n    }\r\n}\r\n\r\nclass LangArray extends LangValueObject {\r\n    constructor(value, source) {\r\n        super(value, source, Types.ARRAY)\r\n\r\n        this.concat = new LangNativeFunction(x => new LangArray(this.value.concat(x.value)))\r\n\r\n        this.plus = this.concat\r\n        for (let s of FeatureLocalizations.SIZE) this[s] = new LangNumber(this.value.length)\r\n\r\n        this.eq = new LangNativeFunction(x => {\r\n            if (!x || !x.value) return new LangBoolean(false)\r\n            if (this.value.length !== x.value.length) return new LangBoolean(false)\r\n            for (let i = 0; i < this.value.length; i++)\r\n                if (!this.value[i].eq || !this.value[i].eq.isNative || !this.value[i].eq.call(x.value[i]).value) return new LangBoolean(false)\r\n            return new LangBoolean(true)\r\n        })\r\n        this.ne = new LangNativeFunction(x => new LangBoolean(!(this.eq.call(x).value)))\r\n    }\r\n    element(indexes, newValue) {\r\n        return indexes.reduce((a,c,i) => {\r\n            const index = Math.ceil(c.value)\r\n            if (index < 0 || index >= a.value.length) throw new LangError(Errors.ARRAY_INDEX_OUT_BOUNDS, null, index)\r\n            const v = a.value[index]\r\n            // set the value for the last element\r\n            if (newValue && i === indexes.length - 1)\r\n                a.value[index] = newValue            \r\n            return v\r\n        }, this)\r\n    }\r\n    attribute(name, newValue) {\r\n        if (FeatureLocalizations.SIZE.includes(name.toLowerCase())) {\r\n            if (newValue) throw new LangError(Errors.READONLY_ATTRIBUTE)\r\n            return new LangNumber(this.value.length)\r\n        }\r\n        return super.attribute(name, newValue)\r\n    }\r\n    hasAttribute(name) {\r\n        return FeatureLocalizations.SIZE.includes(name.toLowerCase()) || super.attribute(name, newValue)\r\n    }\r\n    copy() {\r\n        return new LangArray(this.value.map(p => p.copy()), this.source)\r\n    }\r\n}\r\n\r\nclass LangVoid extends LangValueObject {\r\n    constructor(source) {\r\n        super(null, source, Types.VOID)\r\n\r\n        this.eq = new LangNativeFunction(x => new LangBoolean(false))\r\n        this.ne = new LangNativeFunction(x => new LangBoolean(false))\r\n    }\r\n}\r\n\r\nclass LangFunction {\r\n    constructor(body, args, funcId, source) {\r\n        this.type = Types.FUNCTION\r\n        this.body = body\r\n        this.args = args\r\n        this.isFunction = true\r\n        this.source = source\r\n        this.funcId = funcId\r\n\r\n        this.eq = new LangNativeFunction(g => new LangBoolean(g.funcId === this.funcId))\r\n        this.ne = new LangNativeFunction(g => new LangBoolean(g.funcId !== this.funcId))\r\n    }\r\n    attribute(name, newValue) {\r\n        if (newValue) throw new LangError(Errors.READONLY_ATTRIBUTE)\r\n        const value = this[name] ? this[name] : this.value[name] // explicit attrs have priority over native ones\r\n        if (value) return value\r\n    }\r\n    hasAttribute(name) {\r\n        return this[name] || this.value[name]\r\n    }\r\n    protectedAttributes() {\r\n        return true\r\n    }\r\n    copy() {\r\n        return new LangFunction(this.body, this.args, this.funcId, this.source)\r\n    }\r\n}\r\n\r\nclass LangNativeFunction {\r\n    constructor(func, source) {\r\n        this.type = Types.FUNCTION\r\n        this.func = func\r\n        this.isNative = true\r\n        this.source = source\r\n    }\r\n    call(...params) {\r\n        return this.func(...params)\r\n    }\r\n    copy() {\r\n        return this // immutable\r\n    }\r\n}\r\n\r\nfunction areObjectsEqual(a, b) {\r\n    const aKeys = Object.keys(a.value)\r\n    const bKeys = Object.keys(b.value)\r\n    if (aKeys.length !== bKeys.length) return false\r\n    for (k of aKeys) {\r\n        if (!a.value[k].eq.call(b.value[k])) return false\r\n    }\r\n    return true\r\n}\r\n\r\nmodule.exports = {\r\n    Keywords,\r\n    Errors,\r\n    Interruptions,\r\n    Types,\r\n    Block,\r\n    Assignment,\r\n    While,\r\n    If,\r\n    Expression,\r\n    Variable,\r\n    UniOperator,\r\n    BiOperator,\r\n    ArrayAccess,\r\n    ObjectAccess,\r\n    FunctionCall,\r\n    VarReference,\r\n    ParseError: LangParseError,\r\n    InterpretError: LangInterpretError,\r\n    Interrupt: LangInterrupt,\r\n    Object: LangObject,\r\n    Number: LangNumber,\r\n    String: LangString,\r\n    Boolean: LangBoolean,\r\n    Array: LangArray,\r\n    Function: LangFunction,\r\n    NativeFunction: LangNativeFunction,\r\n    Void: LangVoid,\r\n}","const lang = require('./lang')\r\nconst Parser = require('./parser')\r\nconst Interpret = require('./interpreter')\r\n\r\nclass LudolfC {\r\n    /**\r\n     * @param {object} imports \r\n     * @param {isInterrupted: () => boolean} controls \r\n     */\r\n    constructor(imports = {}, controls = {}) {\r\n        this.parser = new Parser()\r\n        this.interpret = new Interpret(imports, controls)\r\n    }\r\n\r\n    /**\r\n     * Execute LudolfC code.\r\n     * @param {string} code \r\n     * @returns result of the execution\r\n     */\r\n    async execute(code) {\r\n        try {\r\n            const ast = this.parser.parse(code)\r\n            return await this.interpret.execute(ast)\r\n\r\n        } catch (e) {\r\n            if (e.isLangError && (e.position || e.position === 0)) {\r\n                const {line, col} = lineAndCol(this.parser.source.code, e.position)\r\n                e.line = line\r\n                e.col = col\r\n            }\r\n            throw e\r\n        }\r\n    }\r\n\r\n    hasVariable(name) {\r\n        return this.interpret.variables.hasVariable(name)\r\n    }\r\n\r\n    getVariable(name) {\r\n        return this.interpret.variables.getVariable(name)\r\n    }\r\n}\r\n\r\nfunction lineAndCol(code, position) {\r\n    let line = 1    // starting from 1\r\n    let col = 1\r\n    for (let i = 0; i < code.length && i <= position; i++) {\r\n        col++\r\n        if ('\\n' === code.charAt(i)) {\r\n            line++\r\n            col = 1\r\n        }\r\n    }\r\n    col = Math.max(1, col - 1)\r\n    return {line, col}\r\n}\r\n\r\nmodule.exports = { LudolfC, lang }\r\n","const { \r\n    Errors,\r\n    Keywords,\r\n    Block,\r\n    Assignment,\r\n    While,\r\n    If,\r\n    Expression,\r\n    Variable,\r\n    UniOperator,\r\n    BiOperator,\r\n    ArrayAccess,\r\n    ObjectAccess,\r\n    FunctionCall,\r\n    VarReference,\r\n    ParseError: LangParseError,\r\n    Object: LangObject,\r\n    Number: LangNumber,\r\n    String: LangString,\r\n    Boolean: LangBoolean,\r\n    Array: LangArray,\r\n    Function: LangFunction,\r\n    Void: LangVoid } = require('./lang')\r\n\r\nconst UniOperators = ['!', '-']\r\nconst BiOperators = ['*', '/', '%', '+', '-', '<', '<=', '>', '>=', '=', '!=', '&', '|']\r\n\r\nconst RE_NATIONAL_CHARS = ``\r\nconst RE_IDENTIFIER = `[a-zA-Z_${RE_NATIONAL_CHARS}][a-zA-Z0-9_${RE_NATIONAL_CHARS}]*`\r\nconst RE_FUNCTION = `\\\\((\\\\s*(${RE_IDENTIFIER})\\\\s*(,\\\\s*(${RE_IDENTIFIER}))*)?\\\\s*\\\\)\\\\s*\\{(.|\\\\s)*\\\\}`\r\n\r\nclass Source {\r\n    constructor(code, startingAt = 0) {\r\n        this.code = removeComments(code + '\\n')\r\n        this.pos = 0\r\n        this.startingAt = startingAt\r\n\r\n        function removeComments(s) {\r\n            if (!s.length) return s\r\n            let res = ''\r\n            let quote = null\r\n            let inString = false\r\n            let inComment = false\r\n            let i = 0\r\n            for (; i < s.length - 1; i++) {\r\n                const c = s.charAt(i)\r\n\r\n                if (!inString && isStringStarting(c)) {\r\n                    inString = true\r\n                    quote = c\r\n                }\r\n                else if (inString && isStringEnding(c, quote)) {\r\n                    inString = false\r\n                    quote = null\r\n                }\r\n                else if (!inString && c === '/' && s.charAt(i + 1) === '/') inComment = true\r\n                else if (c === '\\n') inComment = false\r\n\r\n                if (!inComment) res += c\r\n            }\r\n            return res + s.charAt(s.length - 1)\r\n        }\r\n    }\r\n\r\n    move(step = 1) {\r\n        this.pos += step\r\n    }\r\n\r\n    currentChar() {\r\n        return this.code.charAt(this.pos)\r\n    }\r\n\r\n    remaining(length = undefined) {\r\n        return this.code.substring(this.pos, Math.min(length ? this.pos + length : this.code.length - 1, this.code.length - 1))\r\n    }\r\n\r\n    next(length = 1) {\r\n        return this.code.substring(Math.min(this.pos + 1, this.code.length - 1), Math.min(this.pos + 1 + length, this.code.length - 1))\r\n    }\r\n\r\n    finished() {\r\n        return this.pos >= this.code.length\r\n    }\r\n\r\n    absPos() {\r\n        return this.pos + this.startingAt - /* last move */ 1 \r\n    }\r\n}\r\n\r\nclass Parser {\r\n    constructor() {    \r\n        this.steps = 0\r\n        this.maxSteps = 1000000 // to prevent infinite loops\r\n        this.fcount = 0 // counter for function IDs\r\n        this.source = new Source('')\r\n    }\r\n\r\n    parse(code) {\r\n        this.steps = 0\r\n        this.source = new Source(code)\r\n        return this.parseBlock(this.source)\r\n    }\r\n\r\n    parseBlock(source) {\r\n        const statements = []\r\n        while (!source.finished()) {\r\n            const stm = this.parseStatement(source)\r\n            if (stm) statements.push(stm)\r\n        }\r\n        return new Block(statements, source.absPos())\r\n    }\r\n\r\n    parseStatement(source) {\r\n        this._stepper()\r\n\r\n        let token = ''\r\n        \r\n        let expecting = null\r\n        let inAssignment = false\r\n\r\n        const openDefinitions = {\r\n            arrays: 0,  // [\r\n            objects: 0, // {\r\n            groups: 0, // (\r\n            ops: 0, // + - * / < > <= >=\r\n        }\r\n\r\n        for (; !source.finished(); source.move()) {\r\n            this._stepper()\r\n\r\n            const c = source.currentChar()\r\n\r\n            // consume the whole string to prevent space-ignoring\r\n            if (!inAssignment && isStringStarting(c)) {\r\n                let cc = c\r\n                do {\r\n                    token += cc\r\n                    source.move()\r\n                    cc = source.currentChar()\r\n                } while (!source.finished() && !isStringEnding(cc, c))\r\n            }\r\n            \r\n            // ignore spaces (except space between numbers)\r\n            if (!expecting && isSpace(c) && isSpace(token.charAt(token.length - 1))) continue\r\n\r\n            if (expecting && c !== expecting) {\r\n                throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), expecting, c)\r\n            }\r\n            if (expecting === '=' && c === expecting) {\r\n                inAssignment = true\r\n                expecting = null\r\n                continue\r\n            }\r\n\r\n            if ('[' === c) openDefinitions.arrays++\r\n            if (']' === c) openDefinitions.arrays--\r\n            if ('{' === c) openDefinitions.objects++\r\n            if ('}' === c) openDefinitions.objects--\r\n            if ('(' === c) openDefinitions.groups++\r\n            if (')' === c) openDefinitions.groups--\r\n            \r\n            if ('+' === c || '-' === c || '*' === c || '/' === c || '<' === c || '>' === c || '=' === c) openDefinitions.ops++\r\n            else openDefinitions.ops && !isSpace(c, true) && openDefinitions.ops--\r\n\r\n            // end of the statement\r\n            if (isStatementSeparator(c) && !openDefinitions.arrays && !openDefinitions.objects && !openDefinitions.groups && !openDefinitions.ops) {\r\n                source.move()\r\n                break\r\n            }\r\n\r\n            // while\r\n            if (isWhileDef(source.remaining())) {\r\n                if (token.length) {\r\n                    throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), token)\r\n                }\r\n                consumeSpaces(source)\r\n                consumeUntil(source, '\\\\s')\r\n                const def = this.parseWhile(source)\r\n                consumeSpaces(source, true)\r\n                if (!isStatementSeparator(source.currentChar())) throw new LangParseError(Errors.EXPECTED_STATEMENT_END, source.absPos())\r\n                return def\r\n            }\r\n\r\n            // if\r\n            if (isIfDef(source.remaining())) {\r\n                if (token.length) {\r\n                    throw new LangParseError(Errors.UNEXPECTED_SYMBOL, token)\r\n                }\r\n                const def = this.parseIfStatement(source)\r\n                return def\r\n            }\r\n\r\n            if (':' === c && !openDefinitions.objects) {    // assignment starting\r\n                if (!(token.trim().length)) throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), c)\r\n                if (isKeyword(token.trim())) throw new LangParseError(Errors.UNEXPECTED_KEYWORD, source.absPos(), c)\r\n                expecting = '='\r\n            } else\r\n            if (inAssignment) {  // variable assignment                \r\n                const value = this.parseExpression(source, openDefinitions)\r\n                token = token.trim()\r\n                if (isIdentifier(token)) {\r\n                    const variable = new Variable(token, source.absPos())\r\n                    const assignment = new Assignment(variable, value, source.absPos())\r\n                    return assignment\r\n                } else {\r\n                    const exp = this.parseExpression(new Source(token, source.absPos() - token.length), {})\r\n                    if (!exp || exp.parts.some(p => p.isOperator && !p.isAccess))\r\n                        throw new LangParseError(Errors.INVALID_IDENTIFIER, source.absPos(), token)\r\n                    const assignment = new Assignment(exp, value, source.absPos())\r\n                    return assignment\r\n                }\r\n            }\r\n            else {\r\n                token += c\r\n            }\r\n        }\r\n\r\n        // statement is an expression\r\n        if (token.length) {\r\n            const exp = this.parseExpression(new Source(token, source.absPos() - token.length), {})\r\n            return exp\r\n        }\r\n    }\r\n\r\n    parseExpression(source, openDefinitions, inGrouping = null) {\r\n        this._stepper()\r\n\r\n        const parts = []\r\n\r\n        while (!source.finished()) {\r\n            this._stepper()\r\n\r\n            const c = source.currentChar()\r\n\r\n            // spaces\r\n            if (isSpace(c)) {\r\n                source.move()\r\n                continue\r\n            }\r\n\r\n            // end of the statement\r\n            if (isStatementSeparator(c) || ')' === c || ']' === c || '}' === c || ',' === c) {\r\n                if ((')' === c || ']' === c || '}' === c) && ((!inGrouping && inGrouping !== c) || !parts.length)) {\r\n                    throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), c)\r\n                }\r\n                // return the list of tokens and operators\r\n                if (parts.length && (!parts[parts.length - 1].isOperator || parts[parts.length - 1].isAccess))\r\n                    return new Expression(parts, source.absPos())\r\n                \r\n                source.move()\r\n                continue\r\n            }\r\n\r\n            // function defition\r\n            if (isFunctionDef(source.remaining())) {\r\n                if (parts.length && !parts[parts.length - 1].isOperator) {\r\n                    throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), c)\r\n                }\r\n                const fn = this.parseFunction(source)\r\n                parts.push(fn)\r\n                continue\r\n            }\r\n\r\n            // object definition\r\n            if ('{' === c) {\r\n                if (!leftOperatorExpected()) {\r\n                    throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), c)\r\n                }\r\n                source.move()\r\n                const attributes = this.readAttributes(source, ')')\r\n\r\n                consumeSpaces(source)\r\n                if ('}' === source.currentChar()) {\r\n                    const obj = new LangObject(attributes, source.absPos())\r\n                    // set the self reference\r\n                    for (let attr of Object.values(attributes)) {\r\n                        if (attr.isObject) {\r\n                            attr.parent = obj\r\n                        }\r\n                    }\r\n                    parts.push(obj)                    \r\n                    source.move()\r\n                    openDefinitions.objects--\r\n                    continue\r\n                }\r\n                throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), source.currentChar(), '}')\r\n            }\r\n\r\n            // grouping or a function call\r\n            if ('(' === c) {\r\n                source.move()\r\n                if (rightOperatorExpected()) {    // a function call\r\n                    const params = this.readList(source, ')')\r\n                    consumeSpaces(source)\r\n    \r\n                    if (')' === source.currentChar()) {\r\n                        var call = new FunctionCall(params, source.absPos())\r\n                        parts.push(call)\r\n                        source.move()\r\n                    } else {\r\n                        throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), source.currentChar(), ')')\r\n                    }\r\n                } else {    // grouping\r\n                    const exp = this.parseExpression(source, openDefinitions, true)\r\n                    parts.push(exp)\r\n                    consumeSpaces(source)\r\n                    if (')' !== source.currentChar()) throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), ')')\r\n                    source.move()\r\n                }\r\n                continue\r\n            }\r\n\r\n            // object attribute access\r\n            if ('.' === c && rightOperatorExpected()) {\r\n                source.move()\r\n                const attrName = this.readIdentifier(source)               \r\n                parts.push(new ObjectAccess(attrName, source.absPos()))\r\n                continue\r\n            }\r\n\r\n            // array\r\n            if ('[' === c) {\r\n                source.move()\r\n                if (rightOperatorExpected()) { // array access\r\n                    const indexes = this.readList(source, ']')\r\n                    consumeSpaces(source)\r\n\r\n                    if (!indexes.length) throw new LangParseError(Errors.ARRAY_INDEX_MISSING, source.absPos())\r\n\r\n                    if (']' === source.currentChar()) {\r\n                        if (indexes.some(i => !i.isExpression || !i.parts.length)) throw new LangParseError(Errors.ARRAY_INDEX_NOT_NUMBER, source.absPos())\r\n                        source.move()\r\n                        parts.push(new ArrayAccess(indexes, source.absPos()))\r\n                    } else {\r\n                        throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), source.currentChar(), ']')\r\n                    }\r\n                } else {    // array definition\r\n                    const elements = this.readList(source, ']')\r\n                    consumeSpaces(source)\r\n    \r\n                    if (']' === source.currentChar()) {\r\n                        parts.push(new LangArray(elements, source.absPos()))\r\n                        source.move()\r\n                        openDefinitions.arrays--\r\n                    } else {\r\n                        throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), source.currentChar(), ']')\r\n                    }\r\n                }\r\n                continue\r\n            }\r\n\r\n            // operators\r\n            if (leftOperatorExpected()) {\r\n                if (UniOperators.includes(c)) {\r\n                    parts.push(new UniOperator(c, source.absPos()))\r\n                    source.move()\r\n                    if (isSpace(source.currentChar())) throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), source.currentChar())\r\n                    continue\r\n                }\r\n            } else \r\n            if (rightOperatorExpected()) {\r\n                const next2 = source.remaining(2)\r\n                if (BiOperators.includes(next2)) {\r\n                    parts.push(new BiOperator(next2, source.absPos()))\r\n                    source.move(next2.length)\r\n                    continue\r\n                }\r\n                if (BiOperators.includes(c)) {\r\n                    parts.push(new BiOperator(c, source.absPos()))\r\n                    source.move()\r\n                    continue\r\n                }\r\n            }\r\n\r\n            if (rightOperatorExpected()) throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), source.currentChar())\r\n\r\n            const exp = this.parseMemberExpression(source)\r\n            parts.push(exp)\r\n        }\r\n\r\n        // after finished, the statement must be complete\r\n        if (endsWithOperator()) throw new LangParseError(Errors.UNEVEN_OPERATORS, source.absPos() - 1) \r\n\r\n        // ///////////////////////////////////////////\r\n\r\n        function leftOperatorExpected() {\r\n            return !parts.length || (parts[parts.length - 1].isOperator && !parts[parts.length - 1].isAccess)\r\n        }\r\n\r\n        function rightOperatorExpected() {\r\n            return parts.length && (!parts[parts.length - 1].isOperator || parts[parts.length - 1].isAccess)\r\n        }\r\n\r\n        function endsWithOperator() {\r\n            return parts.length && (parts[parts.length - 1].isOperator && !parts[parts.length - 1].isAccess)\r\n        }\r\n    }\r\n\r\n    parseMemberExpression(source) {\r\n        this._stepper()\r\n\r\n        let token = ''\r\n\r\n        for (; !source.finished(); source.move()) {\r\n            this._stepper()\r\n            \r\n            const c = source.currentChar()\r\n\r\n            // token ends\r\n            if (isExpressionSeparator(c)) {\r\n                if ('.' === c && /^(0|([1-9][0-9]*))$/.test(token) && /[0-9]/.test(source.next())) { // float number\r\n                    token += c\r\n                    continue\r\n                }\r\n                if (Keywords.TRUE.includes(token.toLowerCase())) {\r\n                    return new LangBoolean(true, source.absPos())\r\n                }\r\n                if (Keywords.FALSE.includes(token.toLowerCase())) {\r\n                    return new LangBoolean(false, source.absPos())\r\n                }\r\n                if (isNumeric(token)) {\r\n                    return new LangNumber(token.includes('.') ? parseFloat(token) : parseInt(token), source.absPos())\r\n                } \r\n                if (isIdentifier(token) || '$' === token) {\r\n                    return new VarReference(token, source.absPos())\r\n                }\r\n                throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), token)\r\n            }\r\n\r\n            if (isStringStarting(c)) {\r\n                source.move()\r\n                return new LangString(this.readString(source, c), source.absPos())\r\n            }\r\n\r\n            token += c\r\n        }\r\n    }\r\n\r\n    parseIfStatement(source) {\r\n        consumeSpaces(source)\r\n        consumeUntil(source, '\\\\s')\r\n        const def = this.parseIf(source)\r\n        consumeSpaces(source, true)\r\n\r\n        let newLine = isStatementSeparator(source.currentChar())\r\n        consumeSpaces(source)\r\n\r\n        if (isElseDef(source.remaining())) {\r\n            consumeUntil(source, '\\\\s')\r\n            def.elseBody = this.parseBody(source)\r\n            consumeSpaces(source, true)\r\n        } else\r\n        if (isElseIfDef(source.remaining())) {\r\n            consumeUntil(source, '\\\\s')\r\n            const elseIf = this.parseIfStatement(source)\r\n            def.elseBody = new Block([elseIf], source.absPos())\r\n            newLine = true\r\n        }\r\n        if (!newLine && !isStatementSeparator(source.currentChar())) throw new LangParseError(Errors.EXPECTED_STATEMENT_END, source.absPos())\r\n        return def\r\n    }\r\n\r\n    readList(source, groupingCloseChar) {\r\n        consumeSpaces(source)\r\n        if (groupingCloseChar === source.currentChar()) {\r\n            return []\r\n        } else {    // multiple params\r\n            const params = []\r\n            do {\r\n                const value = this.parseExpression(source, {}, groupingCloseChar)\r\n                params.push(value)\r\n\r\n                consumeSpaces(source)\r\n\r\n            } while(',' === source.currentChar() && !source.finished())\r\n\r\n            return params\r\n        }\r\n    }\r\n\r\n    readAttributes(source) {\r\n        consumeSpaces(source)\r\n        if ('}' === source.currentChar()) {\r\n            return {}\r\n        } else {    // multiple attributes\r\n            const attributes = {}\r\n            let first = true\r\n            do {\r\n                if (!first) {\r\n                    source.move()\r\n                }\r\n                first = false\r\n                consumeSpaces(source)\r\n\r\n                const name = this.readIdentifier(source)\r\n                if (attributes[name]) {\r\n                    throw new LangParseError(Errors.ATTRIBUTE_ALREADY_EXISTS, source.absPos(), name)\r\n                }\r\n                consumeSpaces(source)\r\n\r\n                if (':' !== source.currentChar()) {\r\n                    throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), ':', source.currentChar())\r\n                }\r\n                source.move()\r\n\r\n                const value = this.parseExpression(source, {}, '}')\r\n                attributes[name] = value\r\n\r\n                consumeSpaces(source)\r\n\r\n            } while(',' === source.currentChar() && !source.finished())\r\n\r\n            return attributes\r\n        }\r\n    }\r\n\r\n    parseWhile(source) {\r\n        const condCode = this.readUntilBodyOpens(source)\r\n        const cond = this.parseExpression(new Source(condCode, source.absPos() - condCode.length), {}, null)\r\n        const body = this.parseBody(source)\r\n        return new While(cond, body, source.absPos())\r\n    }\r\n\r\n    parseIf(source) {\r\n        const condCode = this.readUntilBodyOpens(source)\r\n        const cond = this.parseExpression(new Source(condCode, source.absPos() - condCode.length), {}, null)\r\n        const body = this.parseBody(source)\r\n        return new If(cond, body, null, source.absPos())\r\n    }\r\n\r\n    parseFunction(source) {\r\n        const args = this.readArguments(source)\r\n        const body = this.parseBody(source)\r\n        return new LangFunction(body, args, ++this.fcount, source.absPos())\r\n    }\r\n\r\n    readArguments(source) {\r\n        consumeSpaces(source)\r\n\r\n        if ('(' !== source.currentChar()) {\r\n            throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), '(', source.currentChar())\r\n        }       \r\n        source.move()\r\n        consumeSpaces(source) \r\n\r\n        const args = []\r\n        let first = true\r\n        while((',' === source.currentChar() || ')' !== source.currentChar()) && !source.finished()) {\r\n            if (!first) source.move()\r\n            first = false\r\n\r\n            const name = this.readIdentifier(source)\r\n            args.push(name)\r\n\r\n            consumeSpaces(source)\r\n        }\r\n\r\n        if (')' !== source.currentChar()) {\r\n            throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), ')', source.currentChar())\r\n        }\r\n        source.move()\r\n        return args\r\n    }\r\n\r\n    parseBody(source) {\r\n        consumeSpaces(source)\r\n\r\n        if ('{' !== source.currentChar()) {\r\n            throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), '{', source.currentChar())\r\n        }\r\n\r\n        source.move()\r\n        consumeSpaces(source)\r\n\r\n        let body = ''\r\n        let openQuotings = 0\r\n        while((openQuotings || '}' !== source.currentChar()) && !source.finished()) {\r\n            const c = source.currentChar()\r\n            body += c\r\n            source.move()\r\n\r\n            if ('{' === c) openQuotings++\r\n            if ('}' === c) openQuotings--\r\n        } \r\n\r\n        if ('}' !== source.currentChar()) {\r\n            throw new LangParseError(Errors.EXPECTED_SYMBOL, source.absPos(), '}', source.currentChar())\r\n        }\r\n        source.move()\r\n\r\n        if (/^\\s*$/.test(body)) {\r\n            return new Block([new LangVoid(source.absPos())], source.absPos())\r\n        }\r\n\r\n        const block = this.parseBlock(new Source(body, source.absPos() - body.length))\r\n        return block\r\n    }\r\n    \r\n    readString(source, quoting) {\r\n        let token = ''\r\n        for (; !source.finished(); source.move()) {\r\n            const c = source.currentChar()\r\n\r\n            if (isStringEnding(c, quoting)) {\r\n                source.move()\r\n                return token\r\n            }\r\n            token += c\r\n        }\r\n        throw new LangParseError(Errors.UNEXPECTED_END, source.absPos())\r\n    }\r\n\r\n    readIdentifier(source) {\r\n        let token = ''\r\n        for (; !source.finished(); source.move()) {\r\n            const c = source.currentChar()\r\n            if (isSpace(c)) continue\r\n            if (!new RegExp(`^${RE_IDENTIFIER}$`).test(token + c)) break                \r\n            token += c\r\n        }\r\n        if (token) return token\r\n        throw new LangParseError(Errors.EXPECTED_IDENTIFIER, source.absPos())\r\n    }\r\n\r\n    readUntilBodyOpens(source) {\r\n        let curlies = 0\r\n        let quotations = 0\r\n        let token = ''\r\n        for (; !source.finished(); source.move()) {\r\n            const c = source.currentChar()\r\n            if (isStringStarting(c)) {\r\n                token += this.readString(source, c)\r\n                continue\r\n            }\r\n            if ('(' === c) quotations++\r\n            else\r\n            if (')' === c) quotations--\r\n            else\r\n            if ('{' === c) {\r\n                if (!curlies && !quotations) break\r\n                curlies++\r\n            } else \r\n            if ('}' === c) {\r\n                curlies--\r\n                if (curlies < 0) throw new LangParseError(Errors.UNEXPECTED_SYMBOL, source.absPos(), c)\r\n            }\r\n            token += c\r\n        }\r\n        if (token) return token\r\n    }\r\n\r\n    _stepper() {\r\n        this.steps++\r\n        if (this.steps > this.maxSteps) throw new LangParseError(Errors.PARSER_STEPS_EXCEEDED, source.absPos())\r\n    }\r\n}\r\n\r\nfunction consumeSpaces(source, stopAtNewLine = false) {\r\n    while (!source.finished() && /\\s/.test(source.currentChar()) && (!stopAtNewLine || '\\n' !== source.currentChar())) source.move()\r\n}\r\n\r\nfunction consumeUntil(source, untilChar) {\r\n    const re = new RegExp(untilChar)\r\n    while (!source.finished() && !re.test(source.currentChar())) source.move()\r\n}\r\n\r\nfunction isNumeric(str) {\r\n    return !isNaN(str) && !isNaN(parseFloat(str))\r\n}\r\n\r\nfunction isKeyword(str) {\r\n    str = str.toLowerCase()\r\n    return Object.values(Keywords).some(k => k.includes(str)) ||  Keywords.WHILE.includes(str) || Keywords.IF.includes(str)\r\n}\r\n\r\nfunction isSpace(c, newlines = false) {\r\n    return ('\\n' !== c || newlines) && /\\s+/g.test(c)\r\n}\r\n\r\nfunction isExpressionSeparator(c) {\r\n    return isSpace(c) || isStatementSeparator(c) \r\n        || '(' === c || ')' === c || '[' === c || ']' === c || '{' === c || '}' === c \r\n        || '.' === c || ',' === c\r\n        || BiOperators.some(op => op.startsWith(c)) || UniOperators.some(op => op.startsWith(c))\r\n}\r\n\r\nfunction isStatementSeparator(c) {\r\n    return '\\n' === c || ';' === c\r\n}\r\n\r\nfunction isStringStarting(c) {\r\n    return c === '\"' || c === '' || c === '' || c === \"'\"\r\n}\r\n\r\nfunction isStringEnding(c, quoting) {\r\n    return quoting === c || (c === '' && quoting === '')\r\n}\r\n\r\nfunction isIdentifier(token) {\r\n    return new RegExp(`^${RE_IDENTIFIER}$`).test(token)\r\n}\r\n\r\nfunction isFunctionDef(remaining) {\r\n    return new RegExp(`^${RE_FUNCTION}`).test(remaining)\r\n}\r\n\r\nfunction isWhileDef(remaining) {\r\n    return Keywords.WHILE.some(k => new RegExp(`^\\\\s*${k}\\\\s(.+)\\\\s{`, 's').test(remaining)) \r\n}\r\n\r\nfunction isIfDef(remaining) {\r\n    return Keywords.IF.some(k => new RegExp(`^\\\\s*${k}\\\\s(.+)\\\\s{`, 's').test(remaining))\r\n}\r\n\r\nfunction isElseDef(remaining) {\r\n    return Keywords.ELSE.some(k => new RegExp(`^\\\\s*${k}\\\\s+{`, 's').test(remaining)) \r\n}\r\n\r\nfunction isElseIfDef(remaining) {\r\n    return Keywords.ELSE.some(k => new RegExp(`^\\\\s*${k}\\\\s+(${Keywords.IF.join('|')})`).test(remaining)) \r\n}\r\n\r\nmodule.exports = Parser","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(337);\n"],"names":["root","factory","exports","module","define","amd","this","Types","Errors","Interruptions","InterpretError","LangInterpretError","Interrupt","LangInterrupt","Void","LangVoid","VariablesScope","constructor","imports","variables","Map","parent","Object","entries","forEach","k","v","set","hasVariable","name","has","get","hasAttribute","getVariable","self","attribute","setVariable","value","scoped","found","scope","pushScope","newScope","popScope","copy","FunctionExecution","funcExp","params","isFunctionExecution","ExecutionStepper","maxSteps","isInterruptedFn","steps","step","source","USER_SUSSPEND","EXECUTION_STEPS_EXCEEDED","reset","controls","stepper","isInterrupted","execute","ast","executeBlock","block","result","stm","statements","executeStatement","isExpression","executeExpression","isAssignment","executeAssignment","isWhile","executeWhile","isIf","executeIf","expression","assignNewValue","parts","EMPTY_EXPRESSION","executeExpressionParts","executeShortCircuitExpressionParts","async","op","shouldShortCircuit","index","findFirstOp","left","slice","type","BOOLEAN","WRONG_BI_OPERATOR_SUBJECTS","right","expOr","expAnd","assignApplied","findNextOp","isObjectAccess","isArrayAccess","ACCESS_OPERATOR_EXPECTED","isUni","a","executeExpressionPart","WRONG_UNI_OPERATOR_SUBJECT","apply","removeElementAt","isBi","b","isAddition","STRING","isPrimitive","UNMATCHING_BI_OPERATOR_SUBJECTS","ARRAY","EXPECTED_ARRAY","protectedAttributes","PROTECTED_FROM_MODIFICATION","indexes","Promise","all","map","i","isLastOperator","ATTRIBUTE_NOT_FOUND","o","isObject","isFunction","EXPECTED_OBJECT","isCall","UNKNOWN_OPERATOR","e","isLangError","UNKNOWN_ERROR","isInterpretError","id","arg1","arg2","maxPrecedence","Number","MIN_SAFE_INTEGER","length","isOperator","precedence","arr","filter","_","includes","expressionPart","isReference","varName","UNREFERENCED_VARIABLE","func","p","executeFunctionCall","OBJECT","obj","keys","f","isNative","call","args","FUNC_ARGUMENTS_MISHMASH","variablesBak","arg","body","assignment","WRONG_ASSIGNMENT","isVariable","variable","protected","WRONG_ASSIGNEE_TYPE","whileStm","condition","WRONG_CONDITION","cond","WRONG_CONDITION_VALUE","ifStm","elseBody","FeatureLocalizations","SIZE","INVALID_UNI_OPERATOR","INVALID_BI_OPERATOR","UNEXPECTED_END","UNEXPECTED_SYMBOL","EXPECTED_SYMBOL","UNEXPECTED_KEYWORD","INVALID_IDENTIFIER","UNEVEN_OPERATORS","EXPECTED_FUNCTION","EXPECTED_STATEMENT_END","ARRAY_INDEX_NOT_NUMBER","ARRAY_INDEX_MISSING","ARRAY_INDEX_OUT_BOUNDS","ATTRIBUTE_ALREADY_EXISTS","ELEMENT_NOT_FOUND","OPERATOR_NOT_APPLICABLE","EXPECTED_IDENTIFIER","READONLY_ATTRIBUTE","PARSER_STEPS_EXCEEDED","DIVISION_BY_ZERO","NUMBER","FUNCTION","VOID","LangError","Error","pos","super","details","message","position","Block","s","Statement","Assignment","While","If","bodyElse","Expression","Operator","LangObject","eq","LangNativeFunction","x","LangBoolean","aKeys","bKeys","areObjectsEqual","ne","newValue","isProtected","valueCopy","LangValueObject","LangNumber","mult","div","mod","plus","minus","lt","le","gt","ge","neg","sum","reduce","c","round","Math","floor","ceil","LangString","concat","charAt","sub","j","substring","and","or","xor","nand","LangArray","element","toLowerCase","LangFunction","funcId","g","Keywords","TRUE","FALSE","IF","ELSE","WHILE","Variable","UniOperator","getPrecedence","fn","getFn","BiOperator","ArrayAccess","isAccess","ObjectAccess","attrName","FunctionCall","VarReference","ParseError","isParseError","isLangInterruption","String","Boolean","Array","Function","NativeFunction","lang","Parser","Interpret","LudolfC","parser","interpret","code","parse","line","col","max","lineAndCol","LangParseError","UniOperators","BiOperators","RE_NATIONAL_CHARS","RE_IDENTIFIER","RE_FUNCTION","Source","startingAt","res","quote","inString","inComment","isStringStarting","isStringEnding","removeComments","move","currentChar","remaining","undefined","min","next","finished","absPos","consumeSpaces","stopAtNewLine","test","consumeUntil","untilChar","re","RegExp","isKeyword","str","values","some","isSpace","newlines","isExpressionSeparator","isStatementSeparator","startsWith","quoting","isIdentifier","token","isWhileDef","isIfDef","fcount","parseBlock","parseStatement","push","_stepper","expecting","inAssignment","openDefinitions","arrays","objects","groups","ops","cc","def","parseWhile","parseIfStatement","parseExpression","trim","exp","inGrouping","parseFunction","leftOperatorExpected","attributes","readAttributes","attr","rightOperatorExpected","readList","readIdentifier","elements","next2","parseMemberExpression","isNaN","parseFloat","parseInt","readString","parseIf","newLine","parseBody","join","isElseIfDef","elseIf","groupingCloseChar","first","condCode","readUntilBodyOpens","readArguments","openQuotings","curlies","quotations","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}