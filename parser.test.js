const { Types } = require('./lang')
const Parser = require('./parser')
const parser = new Parser()

test('parser expression number simplest', () => {
  const ast = parser.parse('1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value).toBe(1)
})

test('parser expression number biop', () => {
  const ast = parser.parse('1 + 2')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].value).toBe(2)
})

test('parser expression number biop #2', () => {
  const ast = parser.parse('1 + 2 * 3')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(5)
  expect(ast.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].value).toBe(2)
  expect(ast.statements[0].parts[3].isOperator).toBe(true)
  expect(ast.statements[0].parts[3].isBi).toBe(true)
  expect(ast.statements[0].parts[3].op).toBe('*')
  expect(ast.statements[0].parts[4].type).toBe('NUMBER')
  expect(ast.statements[0].parts[4].value).toBe(3)
})

test('parser expression number uniop', () => {
  const ast = parser.parse('-1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].isUni).toBe(true)
  expect(ast.statements[0].parts[0].op).toBe('-')
  expect(ast.statements[0].parts[1].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].value).toBe(1)
})

test('parser expression number uniop #2', () => {
  const ast = parser.parse('--1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].isUni).toBe(true)
  expect(ast.statements[0].parts[0].op).toBe('-')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isUni).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('-')
  expect(ast.statements[0].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].value).toBe(1)
})

test('parser expression number uniop #3', () => {
  const ast = parser.parse('!!-1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(4)
  expect(ast.statements[0].parts[0].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].isUni).toBe(true)
  expect(ast.statements[0].parts[0].op).toBe('!')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isUni).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('!')
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isUni).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('-')
  expect(ast.statements[0].parts[3].type).toBe('NUMBER')
  expect(ast.statements[0].parts[3].value).toBe(1)
})

test('parser expression numbers ops', () => {
  const ast = parser.parse('-1 + 2 - -3')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(7)
  expect(ast.statements[0].parts[0].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].isUni).toBe(true)
  expect(ast.statements[0].parts[0].op).toBe('-')
  expect(ast.statements[0].parts[1].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].value).toBe(1)
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isBi).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('+')
  expect(ast.statements[0].parts[3].type).toBe('NUMBER')
  expect(ast.statements[0].parts[3].value).toBe(2)
  expect(ast.statements[0].parts[4].isOperator).toBe(true)
  expect(ast.statements[0].parts[4].isBi).toBe(true)
  expect(ast.statements[0].parts[4].op).toBe('-')
  expect(ast.statements[0].parts[5].isOperator).toBe(true)
  expect(ast.statements[0].parts[5].isUni).toBe(true)
  expect(ast.statements[0].parts[5].op).toBe('-')
  expect(ast.statements[0].parts[6].type).toBe('NUMBER')
  expect(ast.statements[0].parts[6].value).toBe(3)
})

test('parser expression numbers ops block', () => {
  const ast = parser.parse('-1 + (2 - -3)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(4)
  expect(ast.statements[0].parts[0].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].isUni).toBe(true)
  expect(ast.statements[0].parts[0].op).toBe('-')
  expect(ast.statements[0].parts[1].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].value).toBe(1)
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isBi).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('+')  
  expect(ast.statements[0].parts[3].isExpression).toBe(true)
  expect(ast.statements[0].parts[3].parts).toHaveLength(4)
  expect(ast.statements[0].parts[3].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[3].parts[0].value).toBe(2)
  expect(ast.statements[0].parts[3].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[3].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[3].parts[1].op).toBe('-')
  expect(ast.statements[0].parts[3].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[3].parts[2].isUni).toBe(true)
  expect(ast.statements[0].parts[3].parts[2].op).toBe('-')
  expect(ast.statements[0].parts[3].parts[3].type).toBe('NUMBER')
  expect(ast.statements[0].parts[3].parts[3].value).toBe(3)
})

test('parser expression group', () => {
  const ast = parser.parse('(1)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].parts[0].value).toBe(1)
})

test('parser expression group #2', () => {
  const ast = parser.parse('((1))')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].parts[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].parts[0].parts[0].value).toBe(1)
})

test('parser expression group #3', () => {
  const ast = parser.parse('((1)+((2)))')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts).toHaveLength(3)
  
  expect(ast.statements[0].parts[0].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].parts[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].parts[0].parts[0].value).toBe(1)

  expect(ast.statements[0].parts[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].parts[1].op).toBe('+')

  expect(ast.statements[0].parts[0].parts[2].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts[2].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].parts[2].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts[2].parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].parts[2].parts[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].parts[2].parts[0].parts[0].value).toBe(2)
})

test('parser expression object', () => {
  const ast = parser.parse('{a:1}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('OBJECT')
  expect(Object.keys(ast.statements[0].parts[0].value)).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.a.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.a.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.a.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value.a.parts[0].value).toBe(1)
})

test('parser expression object #2', () => {
  const ast = parser.parse('{a:1,b:"x"}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('OBJECT')
  expect(Object.keys(ast.statements[0].parts[0].value)).toHaveLength(2)
  expect(ast.statements[0].parts[0].value.a.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.a.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.a.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value.a.parts[0].value).toBe(1)
  expect(ast.statements[0].parts[0].value.b.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.b.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.b.parts[0].type).toBe('STRING')
  expect(ast.statements[0].parts[0].value.b.parts[0].value).toBe('x')
})

test('parser expression object complex', () => {
  const ast = parser.parse('{a:1,b:"x",c:{x:true},d:[3,4]}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('OBJECT')
  expect(Object.keys(ast.statements[0].parts[0].value)).toHaveLength(4)
  expect(ast.statements[0].parts[0].value.a.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.a.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.a.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value.a.parts[0].value).toBe(1)
  expect(ast.statements[0].parts[0].value.b.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.b.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.b.parts[0].type).toBe('STRING')
  expect(ast.statements[0].parts[0].value.b.parts[0].value).toBe('x')
  expect(ast.statements[0].parts[0].value.c.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.c.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.c.parts[0].type).toBe('OBJECT')
  expect(Object.keys(ast.statements[0].parts[0].value.c.parts[0].value)).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.c.parts[0].value.x.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.c.parts[0].value.x.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.c.parts[0].value.x.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].parts[0].value.c.parts[0].value.x.parts[0].value).toBe(true)
  expect(ast.statements[0].parts[0].value.d.parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value.d.parts[0].value).toHaveLength(2)
  expect(ast.statements[0].parts[0].value.d.parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.d.parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.d.parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value.d.parts[0].value[0].parts[0].value).toBe(3)
  expect(ast.statements[0].parts[0].value.d.parts[0].value[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.d.parts[0].value[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.d.parts[0].value[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value.d.parts[0].value[1].parts[0].value).toBe(4)
})

test('parser expression array', () => {
  const ast = parser.parse('[1,2]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value).toHaveLength(2)
  expect(ast.statements[0].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[0].value[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[1].parts[0].value).toBe(2)
})

test('parser expression array #2', () => {
  const ast = parser.parse('[123,"abc",true]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value).toHaveLength(3)
  expect(ast.statements[0].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[0].parts[0].value).toBe(123)
  expect(ast.statements[0].parts[0].value[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].type).toBe('STRING')
  expect(ast.statements[0].parts[0].value[1].parts[0].value).toBe('abc')
  expect(ast.statements[0].parts[0].value[2].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[2].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[2].parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].parts[0].value[2].parts[0].value).toBe(true)
})

test('parser expression array expression', () => {
  const ast = parser.parse('[1+2]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[0].value[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].value[0].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[0].parts[2].value).toBe(2)
})

test('parser expression array dimensions', () => {
  const ast = parser.parse('[[1],[2,3]]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value).toHaveLength(2)
  expect(ast.statements[0].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value[0].parts[0].value).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[0].parts[0].value[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[0].value[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value[1].parts[0].value).toHaveLength(2)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].parts[0].value).toBe(2)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[1].parts[0].value[1].parts[0].value).toBe(3)
})

test('parser expression array complex', () => {
  const ast = parser.parse('[1,[2],{a:3},[{b:[4+5]}]]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value).toHaveLength(4)

  expect(ast.statements[0].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[0].parts[0].value).toBe(1)

  expect(ast.statements[0].parts[0].value[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value[1].parts[0].value).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].parts[0].value).toBe(2)

  expect(ast.statements[0].parts[0].value[2].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[2].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[2].parts[0].type).toBe('OBJECT')
  expect(Object.keys(ast.statements[0].parts[0].value[2].parts[0].value)).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[2].parts[0].value.a.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[2].parts[0].value.a.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[2].parts[0].value.a.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[2].parts[0].value.a.parts[0].value).toBe(3)

  expect(ast.statements[0].parts[0].value[3].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[3].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[3].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value[3].parts[0].value).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].type).toBe('OBJECT')
  expect(Object.keys(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value)).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[0].value).toBe(4)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[2].value).toBe(5)
})

test('parser expression array access', () => {
  const ast = parser.parse('a[0]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('[]')
  expect(ast.statements[0].parts[1].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[0].parts[0].value).toBe(0)
})

test('parser expression array access #2', () => {
  const ast = parser.parse('a[1,2]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('[]')
  expect(ast.statements[0].parts[1].indexes).toHaveLength(2)
  expect(ast.statements[0].parts[1].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].indexes[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[1].parts[0].value).toBe(2)
})

test('parser expression array access #3', () => {
  const ast = parser.parse('a[1,2][3]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('[]')
  expect(ast.statements[0].parts[1].indexes).toHaveLength(2)
  expect(ast.statements[0].parts[1].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].indexes[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[1].parts[0].value).toBe(2)
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('[]')
  expect(ast.statements[0].parts[2].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[2].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[2].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].indexes[0].parts[0].value).toBe(3)
})

test('parser expression array access op', () => {
  const ast = parser.parse('a[1]+a[2]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(5)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('[]')
  expect(ast.statements[0].parts[1].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isBi).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('+')
  expect(ast.statements[0].parts[3].isReference).toBe(true)
  expect(ast.statements[0].parts[3].varName).toBe('a')
  expect(ast.statements[0].parts[4].isOperator).toBe(true)
  expect(ast.statements[0].parts[4].isAccess).toBe(true)
  expect(ast.statements[0].parts[4].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[4].op).toBe('[]')
  expect(ast.statements[0].parts[4].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[4].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[4].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[4].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[4].indexes[0].parts[0].value).toBe(2)
})

test('parser expression object access', () => {
  const ast = parser.parse('o.a')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('a')
})

test('parser expression object access', () => {
  const ast = parser.parse('o.a.b')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('a')
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('.')
  expect(ast.statements[0].parts[2].attrName).toBe('b')
})

test('parser expression object array access', () => {
  const ast = parser.parse('o.a.b[3]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(4)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('a')
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('.')
  expect(ast.statements[0].parts[2].attrName).toBe('b')
  expect(ast.statements[0].parts[3].isOperator).toBe(true)
  expect(ast.statements[0].parts[3].isAccess).toBe(true)
  expect(ast.statements[0].parts[3].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[3].op).toBe('[]')
  expect(ast.statements[0].parts[3].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[3].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[3].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[3].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[3].indexes[0].parts[0].value).toBe(3)
})

test('parser expression object array access #2', () => {
  const ast = parser.parse('o[3].a')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('[]')
  expect(ast.statements[0].parts[1].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[0].parts[0].value).toBe(3)
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('.')
  expect(ast.statements[0].parts[2].attrName).toBe('a')
})

test('parser expression object array access #3', () => {
  const ast = parser.parse('o.a[3].b')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(4)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('a')
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('[]')
  expect(ast.statements[0].parts[2].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[2].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[2].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].indexes[0].parts[0].value).toBe(3)
  expect(ast.statements[0].parts[3].isOperator).toBe(true)
  expect(ast.statements[0].parts[3].isAccess).toBe(true)
  expect(ast.statements[0].parts[3].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[3].op).toBe('.')
  expect(ast.statements[0].parts[3].attrName).toBe('b')
})

test('parser expression function call', () => {
  const ast = parser.parse('f()')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('f')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(0)
})

test('parser expression function call #2', () => {
  const ast = parser.parse('f(1)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('f')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
})

test('parser expression function call #3', () => {
  const ast = parser.parse('f(1,2)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('f')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(2)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[1].parts[0].value).toBe(2)
})

test('parser expression function call #4', () => {
  const ast = parser.parse('o.f()')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('f')
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isCall).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('()')
  expect(ast.statements[0].parts[2].params).toHaveLength(0)
})

test('parser expression function call #5', () => {
  const ast = parser.parse('o.f(1)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('f')  
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isCall).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('()')
  expect(ast.statements[0].parts[2].params).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].params[0].parts[0].value).toBe(1)
})

test('parser expression function call #6', () => {
  const ast = parser.parse('o.f(1,2)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('f')  
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isCall).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('()')
  expect(ast.statements[0].parts[2].params).toHaveLength(2)
  expect(ast.statements[0].parts[2].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[2].params[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].params[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].params[1].parts[0].value).toBe(2)
})

test('parser expression function call #7', () => {
  const ast = parser.parse('o.f(1 + 2)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('f')  
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isCall).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('()')
  expect(ast.statements[0].parts[2].params).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].params[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[2].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[2].params[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].params[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[2].params[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[2].params[0].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].params[0].parts[2].value).toBe(2)
})

test('parser expression function def simplest', () => {
  const ast = parser.parse('(){}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].type).toBe('VOID')
})

test('parser expression function def param', () => {
  const ast = parser.parse('(a){}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(1)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].type).toBe('VOID')
})

test('parser expression function def params', () => {
  const ast = parser.parse('(a,b){}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].args[1]).toBe('b')
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].type).toBe('VOID')
})

test('parser expression function def body', () => {
  const ast = parser.parse('(a,b){a + b}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].args[1]).toBe('b')
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].value.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[0].value.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].value.statements[0].parts[2].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[2].varName).toBe('b')
})

test('parser expression function def body #2', () => {
  const ast = parser.parse('(a,b){x := a + b\nx + 1}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].args[1]).toBe('b')
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(2)

  expect(ast.statements[0].parts[0].value.statements[0].isAssignment).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].left.name).toBe('x')  
  expect(ast.statements[0].parts[0].value.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].right.parts).toHaveLength(3)  
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[2].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[2].varName).toBe('b')
  
  expect(ast.statements[0].parts[0].value.statements[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[1].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].value.statements[1].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[1].parts[0].varName).toBe('x')
  expect(ast.statements[0].parts[0].value.statements[1].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[1].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[1].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].value.statements[1].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value.statements[1].parts[2].value).toBe(1)
})

test('parser expression function def+call simplest', () => {
  const ast = parser.parse('(){}()')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].type).toBe('VOID')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(0)
})

test('parser expression function def+call param', () => {
  const ast = parser.parse('(a){}(1)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(1)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].type).toBe('VOID')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
})

test('parser expression function def+call params', () => {
  const ast = parser.parse('(a,b){}(1,2)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].args[1]).toBe('b')
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].type).toBe('VOID')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(2)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[1].parts[0].value).toBe(2)
})

test('parser expression function def+call body', () => {
  const ast = parser.parse('(a,b){a + b}(1,2)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].args[1]).toBe('b')
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].value.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[0].value.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].value.statements[0].parts[2].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[2].varName).toBe('b')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(2)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[1].parts[0].value).toBe(2)
})

test('parser expression function def+call body #2', () => {
  const ast = parser.parse('(a,b){x := a + b\nx + 1} ( 1 , 2 )')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].args[1]).toBe('b')
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(2)

  expect(ast.statements[0].parts[0].value.statements[0].isAssignment).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].left.name).toBe('x')  
  expect(ast.statements[0].parts[0].value.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].right.parts).toHaveLength(3)  
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[2].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].right.parts[2].varName).toBe('b')
  
  expect(ast.statements[0].parts[0].value.statements[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[1].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].value.statements[1].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[1].parts[0].varName).toBe('x')
  expect(ast.statements[0].parts[0].value.statements[1].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[1].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[1].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].value.statements[1].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value.statements[1].parts[2].value).toBe(1)

  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(2)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[1].parts[0].value).toBe(2)
})

test('parser expression function', () => {
  const ast = parser.parse('(){}((){})')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].type).toBe(Types.VOID)
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[1].params[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].parts[1].params[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].value.statements[0].type).toBe(Types.VOID)
})

test('parser expression function #2', () => {
  const ast = parser.parse('(x){x}(1+(){2}())')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(1)
  expect(ast.statements[0].parts[0].args[0]).toBe('x')
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[0].varName).toBe('x')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(4)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[1].params[0].parts[2].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[1].params[0].parts[2].args).toHaveLength(0)
  expect(ast.statements[0].parts[1].params[0].parts[2].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[2].value.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[2].value.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[2].value.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[2].value.statements[0].parts[0].value).toBe(2)
  expect(ast.statements[0].parts[1].params[0].parts[3].isCall).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[3].params).toHaveLength(0)
})

test('parser expression function #3', () => {
  const ast = parser.parse('(x){x}(1+(){2}()+3)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(1)
  expect(ast.statements[0].parts[0].args[0]).toBe('x')
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[0].varName).toBe('x')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(6)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[1].params[0].parts[2].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[1].params[0].parts[2].args).toHaveLength(0)
  expect(ast.statements[0].parts[1].params[0].parts[2].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[2].value.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[2].value.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[2].value.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[2].value.statements[0].parts[0].value).toBe(2)
  expect(ast.statements[0].parts[1].params[0].parts[3].isCall).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[3].params).toHaveLength(0)
  expect(ast.statements[0].parts[1].params[0].parts[4].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[4].isBi).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[4].op).toBe('+')
  expect(ast.statements[0].parts[1].params[0].parts[5].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[5].value).toBe(3)
})

test('parser expression function #4', () => {
  const ast = parser.parse('(x){x}((1))')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(1)
  expect(ast.statements[0].parts[0].args[0]).toBe('x')
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[0].varName).toBe('x')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].parts[0].value).toBe(1)
})

test('parser expression function #5', () => {
  const ast = parser.parse('(f,g){f()+g()}((){1},(){2})')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('f')
  expect(ast.statements[0].parts[0].args[1]).toBe('g')
  expect(ast.statements[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts).toHaveLength(5)
  expect(ast.statements[0].parts[0].value.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[0].varName).toBe('f')
  expect(ast.statements[0].parts[0].value.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[1].params).toHaveLength(0)
  expect(ast.statements[0].parts[0].value.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[2].isBi).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[2].op).toBe('+')
  expect(ast.statements[0].parts[0].value.statements[0].parts[3].isReference).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[3].varName).toBe('g')
  expect(ast.statements[0].parts[0].value.statements[0].parts[4].isCall).toBe(true)
  expect(ast.statements[0].parts[0].value.statements[0].parts[4].params).toHaveLength(0)
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(2)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[1].params[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].parts[1].params[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].value.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[0].value.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].value.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[1].params[1].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].parts[1].params[1].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].value.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[1].parts[0].value.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].value.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[1].parts[0].value.statements[0].parts[0].value).toBe(2)
})

test('parser expression native function', () => {
  const ast = parser.parse('1.plus(2)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('plus')  
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isCall).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('()')
  expect(ast.statements[0].parts[2].params).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].params[0].parts[0].value).toBe(2)
})

test('parser assignment number simplest', () => {
  const ast = parser.parse('a := 1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)
  
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].left.name).toBe('a')
  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
})

test('parser assignment number simplest #2', () => {
  const ast = parser.parse('a := 1 / 2')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)
  
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].left.name).toBe('a')
  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(3)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
  expect(ast.statements[0].right.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].right.parts[1].isBi).toBe(true)
  expect(ast.statements[0].right.parts[1].op).toBe('/')
  expect(ast.statements[0].right.parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[2].value).toBe(2)
})

test('parser assignment with object access', () => {
  const ast = parser.parse('o.a := 1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)
  
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isExpression).toBe(true)
  expect(ast.statements[0].left.parts).toHaveLength(2)
  expect(ast.statements[0].left.parts[0].isReference).toBe(true)
  expect(ast.statements[0].left.parts[0].varName).toBe('o')
  expect(ast.statements[0].left.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].left.parts[1].isAccess).toBe(true)
  expect(ast.statements[0].left.parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].left.parts[1].op).toBe('.')
  expect(ast.statements[0].left.parts[1].attrName).toBe('a')
  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
})

test('parser assignment with object access #2', () => {
  const ast = parser.parse('o.a.b := 1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)
  
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isExpression).toBe(true)
  expect(ast.statements[0].left.parts).toHaveLength(3)
  expect(ast.statements[0].left.parts[0].isReference).toBe(true)
  expect(ast.statements[0].left.parts[0].varName).toBe('o')
  expect(ast.statements[0].left.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].left.parts[1].isAccess).toBe(true)
  expect(ast.statements[0].left.parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].left.parts[1].op).toBe('.')
  expect(ast.statements[0].left.parts[1].attrName).toBe('a')  
  expect(ast.statements[0].left.parts[2].isOperator).toBe(true)
  expect(ast.statements[0].left.parts[2].isAccess).toBe(true)
  expect(ast.statements[0].left.parts[2].isObjectAccess).toBe(true)
  expect(ast.statements[0].left.parts[2].op).toBe('.')
  expect(ast.statements[0].left.parts[2].attrName).toBe('b')
  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
})

test('parser assignment with array access', () => {
  const ast = parser.parse('a[3] := 1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)
  
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isExpression).toBe(true)
  expect(ast.statements[0].left.parts).toHaveLength(2)
  expect(ast.statements[0].left.parts[0].isReference).toBe(true)
  expect(ast.statements[0].left.parts[0].varName).toBe('a')
  expect(ast.statements[0].left.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].left.parts[1].isAccess).toBe(true)
  expect(ast.statements[0].left.parts[1].isArrayAccess).toBe(true)
  expect(ast.statements[0].left.parts[1].indexes).toHaveLength(1)
  expect(ast.statements[0].left.parts[1].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].left.parts[1].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].left.parts[1].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].left.parts[1].indexes[0].parts[0].value).toBe(3)
  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
})

test('parser assignment function def body', () => {
  const ast = parser.parse('f := (x){x := x + 1\nx + 2}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)

  expect(ast.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].left.name).toBe('f')

  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].right.parts[0].args).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].args[0]).toBe('x')
  expect(ast.statements[0].right.parts[0].value.statements).toHaveLength(2)

  expect(ast.statements[0].right.parts[0].value.statements[0].isAssignment).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[0].left.name).toBe('x')  
  expect(ast.statements[0].right.parts[0].value.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts).toHaveLength(3)  
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[0].isReference).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[0].varName).toBe('x')
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[1].isBi).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[1].op).toBe('+')
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[2].value).toBe(1)
  
  expect(ast.statements[0].right.parts[0].value.statements[1].isExpression).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[1].parts).toHaveLength(3)
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[0].isReference).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[0].varName).toBe('x')
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[1].isBi).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[1].op).toBe('+')
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[2].value).toBe(2)
})

test('parser assignment function def body #2', () => {
  const ast = parser.parse('f := (a,b){x := a + b\nx + 1}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)

  expect(ast.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].left.name).toBe('f')

  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].right.parts[0].args).toHaveLength(2)
  expect(ast.statements[0].right.parts[0].args[0]).toBe('a')
  expect(ast.statements[0].right.parts[0].args[1]).toBe('b')
  expect(ast.statements[0].right.parts[0].value.statements).toHaveLength(2)

  expect(ast.statements[0].right.parts[0].value.statements[0].isAssignment).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[0].left.name).toBe('x')  
  expect(ast.statements[0].right.parts[0].value.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts).toHaveLength(3)  
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[0].isReference).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[0].varName).toBe('a')
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[1].isBi).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[1].op).toBe('+')
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[2].isReference).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[0].right.parts[2].varName).toBe('b')
  
  expect(ast.statements[0].right.parts[0].value.statements[1].isExpression).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[1].parts).toHaveLength(3)
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[0].isReference).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[0].varName).toBe('x')
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[1].isBi).toBe(true)
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[1].op).toBe('+')
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value.statements[1].parts[2].value).toBe(1)
})

test('parser statement multiple', () => {
  const ast = parser.parse('a := 1\na + 2')
  expect(ast.statements).toHaveLength(2)
  
  expect(ast.statements[0].isAssignment).toBe(true)
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].left.name).toBe('a')  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
  
  expect(ast.statements[1].isExpression).toBe(true)
  expect(ast.statements[1].parts).toHaveLength(3)
  expect(ast.statements[1].parts[0].isReference).toBe(true)
  expect(ast.statements[1].parts[0].varName).toBe('a')
  expect(ast.statements[1].parts[1].isOperator).toBe(true)
  expect(ast.statements[1].parts[1].isBi).toBe(true)
  expect(ast.statements[1].parts[1].op).toBe('+')
  expect(ast.statements[1].parts[2].type).toBe('NUMBER')
  expect(ast.statements[1].parts[2].value).toBe(2)
})

test('parser statement multiple #2', () => {
  const ast = parser.parse('a := 1\nb := 2\nc := a + b')
  expect(ast.statements).toHaveLength(3)
  
  expect(ast.statements[0].isAssignment).toBe(true)
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].left.name).toBe('a')  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
  
  expect(ast.statements[1].isAssignment).toBe(true)
  expect(ast.statements[1].left).toBeDefined()
  expect(ast.statements[1].left.isVariable).toBe(true)
  expect(ast.statements[1].left.name).toBe('b')  
  expect(ast.statements[1].right).toBeDefined()
  expect(ast.statements[1].right.isExpression).toBe(true)
  expect(ast.statements[1].right.parts).toHaveLength(1)
  expect(ast.statements[1].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[1].right.parts[0].value).toBe(2)
  
  expect(ast.statements[2].isAssignment).toBe(true)
  expect(ast.statements[2].left).toBeDefined()
  expect(ast.statements[2].left.isVariable).toBe(true)
  expect(ast.statements[2].left.name).toBe('c')  
  expect(ast.statements[2].right).toBeDefined()
  expect(ast.statements[2].right.isExpression).toBe(true)
  expect(ast.statements[2].right.parts).toHaveLength(3)
  expect(ast.statements[2].right.parts[0].isReference).toBe(true)
  expect(ast.statements[2].right.parts[0].varName).toBe('a')
  expect(ast.statements[2].right.parts[1].isOperator).toBe(true)
  expect(ast.statements[2].right.parts[1].isBi).toBe(true)
  expect(ast.statements[2].right.parts[1].op).toBe('+')
  expect(ast.statements[2].right.parts[2].isReference).toBe(true)
  expect(ast.statements[2].right.parts[2].varName).toBe('b')
})

test('parser statement while', () => {
  const ast = parser.parse('while true {}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
})

test('parser statement while #2', () => {
  const ast = parser.parse('while (true) {}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].isExpression).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
})

test('parser statement while #3', () => {
  const ast = parser.parse('while 1 < 2 {}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(3)
  expect(ast.statements[0].condition.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].condition.parts[0].value).toBe(1)
  expect(ast.statements[0].condition.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].condition.parts[1].isBi).toBe(true)
  expect(ast.statements[0].condition.parts[1].op).toBe('<')
  expect(ast.statements[0].condition.parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].condition.parts[2].value).toBe(2)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
})

test('parser statement while #4', () => { // functions in the condition must be enclosed in quotations
  const ast = parser.parse('while ((){true}()) {}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].isExpression).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts).toHaveLength(2)
  expect(ast.statements[0].condition.parts[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].condition.parts[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].condition.parts[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].parts[0].value.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[0].value.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].parts[0].value.statements[0].parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].parts[0].value.statements[0].parts[0].value).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[1].params).toHaveLength(0)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
})

test('parser statement while #5', () => { // functions in the condition must be enclosed in quotations
  const ast = parser.parse('while ((){true}() | false) {}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].isExpression).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts).toHaveLength(4)
  expect(ast.statements[0].condition.parts[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].condition.parts[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].condition.parts[0].parts[0].value.statements).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].parts[0].value.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[0].value.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].parts[0].value.statements[0].parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].parts[0].value.statements[0].parts[0].value).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[1].params).toHaveLength(0)
  expect(ast.statements[0].condition.parts[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[2].isBi).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[2].op).toBe('|')
  expect(ast.statements[0].condition.parts[0].parts[3].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].parts[3].value).toBe(false)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
})

test('parser statement while #6', () => {
  const ast = parser.parse('while true {1}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].body.statements[0].parts[0].value).toBe(1)
})

test('parser statement while #7', () => {
  const ast = parser.parse('while true {1}\nwhile false {2}')
  expect(ast.statements).toHaveLength(2)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].body.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[1].isWhile).toBe(true)
  expect(ast.statements[1].condition.isExpression).toBe(true)
  expect(ast.statements[1].condition.parts).toHaveLength(1)
  expect(ast.statements[1].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[1].condition.parts[0].value).toBe(false)
  expect(ast.statements[1].body.statements).toHaveLength(1)
  expect(ast.statements[1].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[1].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[1].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[1].body.statements[0].parts[0].value).toBe(2)
})

test('interpret statement while #8', () => {
  const ast = parser.parse('a := 0\nb := 0\nwhile a < 10 { b := b + 1\na := a + 2 }\nb')
  expect(ast.statements).toHaveLength(4)
  expect(ast.statements[0].isAssignment).toBe(true)
  expect(ast.statements[1].isAssignment).toBe(true)
  expect(ast.statements[2].isWhile).toBe(true)
  expect(ast.statements[2].condition.isExpression).toBe(true)
  expect(ast.statements[2].condition.parts).toHaveLength(3)
  expect(ast.statements[2].condition.parts[0].isReference).toBe(true)
  expect(ast.statements[2].condition.parts[0].varName).toBe('a')
  expect(ast.statements[2].condition.parts[1].isBi).toBe(true)
  expect(ast.statements[2].condition.parts[1].op).toBe('<')
  expect(ast.statements[2].condition.parts[2].type).toBe('NUMBER')
  expect(ast.statements[2].condition.parts[2].value).toBe(10)
  expect(ast.statements[2].body.statements).toHaveLength(2)
  expect(ast.statements[2].body.statements[0].isAssignment).toBe(true)
  expect(ast.statements[2].body.statements[1].isAssignment).toBe(true)
  expect(ast.statements[3].isExpression).toBe(true)
})