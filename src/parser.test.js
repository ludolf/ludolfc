const Parser = require('./parser')
const parser = new Parser()

test('parse expression number simplest', () => {
  const ast = parser.parse('1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value).toBe(1)
})

test('parse expression number biop', () => {
  const ast = parser.parse('1 + 2')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].value).toBe(2)
})

test('parse expression number biop #2', () => {
  const ast = parser.parse('1 + 2 * 3')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(5)
  expect(ast.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].value).toBe(2)
  expect(ast.statements[0].parts[3].isOperator).toBe(true)
  expect(ast.statements[0].parts[3].isBi).toBe(true)
  expect(ast.statements[0].parts[3].op).toBe('*')
  expect(ast.statements[0].parts[4].type).toBe('NUMBER')
  expect(ast.statements[0].parts[4].value).toBe(3)
})

test('parse expression number uniop', () => {
  const ast = parser.parse('-1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].isUni).toBe(true)
  expect(ast.statements[0].parts[0].op).toBe('-')
  expect(ast.statements[0].parts[1].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].value).toBe(1)
})

test('parse expression number uniop #2', () => {
  const ast = parser.parse('--1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].isUni).toBe(true)
  expect(ast.statements[0].parts[0].op).toBe('-')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isUni).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('-')
  expect(ast.statements[0].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].value).toBe(1)
})

test('parse expression number uniop #3', () => {
  const ast = parser.parse('!!-1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(4)
  expect(ast.statements[0].parts[0].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].isUni).toBe(true)
  expect(ast.statements[0].parts[0].op).toBe('!')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isUni).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('!')
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isUni).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('-')
  expect(ast.statements[0].parts[3].type).toBe('NUMBER')
  expect(ast.statements[0].parts[3].value).toBe(1)
})

test('parse expression numbers ops', () => {
  const ast = parser.parse('-1 + 2 - -3')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(7)
  expect(ast.statements[0].parts[0].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].isUni).toBe(true)
  expect(ast.statements[0].parts[0].op).toBe('-')
  expect(ast.statements[0].parts[1].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].value).toBe(1)
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isBi).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('+')
  expect(ast.statements[0].parts[3].type).toBe('NUMBER')
  expect(ast.statements[0].parts[3].value).toBe(2)
  expect(ast.statements[0].parts[4].isOperator).toBe(true)
  expect(ast.statements[0].parts[4].isBi).toBe(true)
  expect(ast.statements[0].parts[4].op).toBe('-')
  expect(ast.statements[0].parts[5].isOperator).toBe(true)
  expect(ast.statements[0].parts[5].isUni).toBe(true)
  expect(ast.statements[0].parts[5].op).toBe('-')
  expect(ast.statements[0].parts[6].type).toBe('NUMBER')
  expect(ast.statements[0].parts[6].value).toBe(3)
})

test('parse expression numbers ops block', () => {
  const ast = parser.parse('-1 + (2 - -3)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(4)
  expect(ast.statements[0].parts[0].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].isUni).toBe(true)
  expect(ast.statements[0].parts[0].op).toBe('-')
  expect(ast.statements[0].parts[1].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].value).toBe(1)
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isBi).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('+')  
  expect(ast.statements[0].parts[3].isExpression).toBe(true)
  expect(ast.statements[0].parts[3].parts).toHaveLength(4)
  expect(ast.statements[0].parts[3].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[3].parts[0].value).toBe(2)
  expect(ast.statements[0].parts[3].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[3].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[3].parts[1].op).toBe('-')
  expect(ast.statements[0].parts[3].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[3].parts[2].isUni).toBe(true)
  expect(ast.statements[0].parts[3].parts[2].op).toBe('-')
  expect(ast.statements[0].parts[3].parts[3].type).toBe('NUMBER')
  expect(ast.statements[0].parts[3].parts[3].value).toBe(3)
})

test('parse expression group', () => {
  const ast = parser.parse('(1)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].parts[0].value).toBe(1)
})

test('parse expression group #2', () => {
  const ast = parser.parse('((1))')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].parts[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].parts[0].parts[0].value).toBe(1)
})

test('parse expression group #3', () => {
  const ast = parser.parse('((1)+((2)))')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts).toHaveLength(3)
  
  expect(ast.statements[0].parts[0].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].parts[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].parts[0].parts[0].value).toBe(1)

  expect(ast.statements[0].parts[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].parts[1].op).toBe('+')

  expect(ast.statements[0].parts[0].parts[2].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts[2].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].parts[2].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].parts[2].parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].parts[2].parts[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].parts[2].parts[0].parts[0].value).toBe(2)
})

test('parse expression object', () => {
  const ast = parser.parse('{a:1}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('OBJECT')
  expect(Object.keys(ast.statements[0].parts[0].value)).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.a.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.a.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.a.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value.a.parts[0].value).toBe(1)
})

test('parse expression object #2', () => {
  const ast = parser.parse('{a:1,b:"x"}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('OBJECT')
  expect(Object.keys(ast.statements[0].parts[0].value)).toHaveLength(2)
  expect(ast.statements[0].parts[0].value.a.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.a.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.a.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value.a.parts[0].value).toBe(1)
  expect(ast.statements[0].parts[0].value.b.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.b.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.b.parts[0].type).toBe('STRING')
  expect(ast.statements[0].parts[0].value.b.parts[0].value).toBe('x')
})

test('parse expression object complex', () => {
  const ast = parser.parse('{a:1,b:"x",c:{x:true},d:[3,4]}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('OBJECT')
  expect(Object.keys(ast.statements[0].parts[0].value)).toHaveLength(4)
  expect(ast.statements[0].parts[0].value.a.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.a.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.a.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value.a.parts[0].value).toBe(1)
  expect(ast.statements[0].parts[0].value.b.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.b.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.b.parts[0].type).toBe('STRING')
  expect(ast.statements[0].parts[0].value.b.parts[0].value).toBe('x')
  expect(ast.statements[0].parts[0].value.c.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.c.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.c.parts[0].type).toBe('OBJECT')
  expect(Object.keys(ast.statements[0].parts[0].value.c.parts[0].value)).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.c.parts[0].value.x.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.c.parts[0].value.x.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.c.parts[0].value.x.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].parts[0].value.c.parts[0].value.x.parts[0].value).toBe(true)
  expect(ast.statements[0].parts[0].value.d.parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value.d.parts[0].value).toHaveLength(2)
  expect(ast.statements[0].parts[0].value.d.parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.d.parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.d.parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value.d.parts[0].value[0].parts[0].value).toBe(3)
  expect(ast.statements[0].parts[0].value.d.parts[0].value[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value.d.parts[0].value[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value.d.parts[0].value[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value.d.parts[0].value[1].parts[0].value).toBe(4)
})

test('parse expression array', () => {
  const ast = parser.parse('[1,2]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value).toHaveLength(2)
  expect(ast.statements[0].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[0].value[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[1].parts[0].value).toBe(2)
})

test('parse expression array #2', () => {
  const ast = parser.parse('[123,"abc",true]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value).toHaveLength(3)
  expect(ast.statements[0].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[0].parts[0].value).toBe(123)
  expect(ast.statements[0].parts[0].value[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].type).toBe('STRING')
  expect(ast.statements[0].parts[0].value[1].parts[0].value).toBe('abc')
  expect(ast.statements[0].parts[0].value[2].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[2].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[2].parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].parts[0].value[2].parts[0].value).toBe(true)
})

test('parse expression array expression', () => {
  const ast = parser.parse('[1+2]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[0].value[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].value[0].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[0].parts[2].value).toBe(2)
})

test('parse expression array dimensions', () => {
  const ast = parser.parse('[[1],[2,3]]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value).toHaveLength(2)
  expect(ast.statements[0].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value[0].parts[0].value).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[0].parts[0].value[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[0].value[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value[1].parts[0].value).toHaveLength(2)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].parts[0].value).toBe(2)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[1].parts[0].value[1].parts[0].value).toBe(3)
})

test('parse expression array complex', () => {
  const ast = parser.parse('[1,[2],{a:3},[{b:[4+5]}]]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value).toHaveLength(4)

  expect(ast.statements[0].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[0].parts[0].value).toBe(1)

  expect(ast.statements[0].parts[0].value[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value[1].parts[0].value).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[1].parts[0].value[0].parts[0].value).toBe(2)

  expect(ast.statements[0].parts[0].value[2].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[2].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[2].parts[0].type).toBe('OBJECT')
  expect(Object.keys(ast.statements[0].parts[0].value[2].parts[0].value)).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[2].parts[0].value.a.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[2].parts[0].value.a.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[2].parts[0].value.a.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[2].parts[0].value.a.parts[0].value).toBe(3)

  expect(ast.statements[0].parts[0].value[3].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[3].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[3].parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value[3].parts[0].value).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].type).toBe('OBJECT')
  expect(Object.keys(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value)).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].type).toBe('ARRAY')
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value).toHaveLength(1)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[0].value).toBe(4)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value[3].parts[0].value[0].parts[0].value.b.parts[0].value[0].parts[2].value).toBe(5)
})

test('parse expression array access', () => {
  const ast = parser.parse('a[0]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('[]')
  expect(ast.statements[0].parts[1].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[0].parts[0].value).toBe(0)
})

test('parse expression array access #2', () => {
  const ast = parser.parse('a[1,2]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('[]')
  expect(ast.statements[0].parts[1].indexes).toHaveLength(2)
  expect(ast.statements[0].parts[1].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].indexes[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[1].parts[0].value).toBe(2)
})

test('parse expression array access #3', () => {
  const ast = parser.parse('a[1,2][3]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('[]')
  expect(ast.statements[0].parts[1].indexes).toHaveLength(2)
  expect(ast.statements[0].parts[1].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].indexes[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[1].parts[0].value).toBe(2)
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('[]')
  expect(ast.statements[0].parts[2].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[2].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[2].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].indexes[0].parts[0].value).toBe(3)
})

test('parse expression array access op', () => {
  const ast = parser.parse('a[1]+a[2]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(5)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('[]')
  expect(ast.statements[0].parts[1].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isBi).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('+')
  expect(ast.statements[0].parts[3].isReference).toBe(true)
  expect(ast.statements[0].parts[3].varName).toBe('a')
  expect(ast.statements[0].parts[4].isOperator).toBe(true)
  expect(ast.statements[0].parts[4].isAccess).toBe(true)
  expect(ast.statements[0].parts[4].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[4].op).toBe('[]')
  expect(ast.statements[0].parts[4].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[4].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[4].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[4].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[4].indexes[0].parts[0].value).toBe(2)
})

test('parse expression object access', () => {
  const ast = parser.parse('o.a')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('a')
})

test('parse expression object access', () => {
  const ast = parser.parse('o.a.b')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('a')
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('.')
  expect(ast.statements[0].parts[2].attrName).toBe('b')
})

test('parse expression object array access', () => {
  const ast = parser.parse('o.a.b[3]')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(4)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('a')
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('.')
  expect(ast.statements[0].parts[2].attrName).toBe('b')
  expect(ast.statements[0].parts[3].isOperator).toBe(true)
  expect(ast.statements[0].parts[3].isAccess).toBe(true)
  expect(ast.statements[0].parts[3].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[3].op).toBe('[]')
  expect(ast.statements[0].parts[3].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[3].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[3].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[3].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[3].indexes[0].parts[0].value).toBe(3)
})

test('parse expression object array access #2', () => {
  const ast = parser.parse('o[3].a')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('[]')
  expect(ast.statements[0].parts[1].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].indexes[0].parts[0].value).toBe(3)
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('.')
  expect(ast.statements[0].parts[2].attrName).toBe('a')
})

test('parse expression object array access #3', () => {
  const ast = parser.parse('o.a[3].b')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(4)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('a')
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isArrayAccess).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('[]')
  expect(ast.statements[0].parts[2].indexes).toHaveLength(1)
  expect(ast.statements[0].parts[2].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[2].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].indexes[0].parts[0].value).toBe(3)
  expect(ast.statements[0].parts[3].isOperator).toBe(true)
  expect(ast.statements[0].parts[3].isAccess).toBe(true)
  expect(ast.statements[0].parts[3].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[3].op).toBe('.')
  expect(ast.statements[0].parts[3].attrName).toBe('b')
})

test('parse expression function call', () => {
  const ast = parser.parse('f()')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('f')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(0)
})

test('parse expression function call #2', () => {
  const ast = parser.parse('f(1)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('f')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
})

test('parse expression function call #3', () => {
  const ast = parser.parse('f(1,2)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('f')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(2)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[1].parts[0].value).toBe(2)
})

test('parse expression function call #4', () => {
  const ast = parser.parse('o.f()')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('f')
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isCall).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('()')
  expect(ast.statements[0].parts[2].params).toHaveLength(0)
})

test('parse expression function call #5', () => {
  const ast = parser.parse('o.f(1)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('f')  
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isCall).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('()')
  expect(ast.statements[0].parts[2].params).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].params[0].parts[0].value).toBe(1)
})

test('parse expression function call #6', () => {
  const ast = parser.parse('o.f(1,2)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('f')  
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isCall).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('()')
  expect(ast.statements[0].parts[2].params).toHaveLength(2)
  expect(ast.statements[0].parts[2].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[2].params[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].params[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].params[1].parts[0].value).toBe(2)
})

test('parse expression function call #7', () => {
  const ast = parser.parse('o.f(1 + 2)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].varName).toBe('o')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('f')  
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isCall).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('()')
  expect(ast.statements[0].parts[2].params).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].params[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[2].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[2].params[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].params[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[2].params[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[2].params[0].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].params[0].parts[2].value).toBe(2)
})

test('parse expression function def simplest', () => {
  const ast = parser.parse('(){}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].type).toBe('VOID')
})

test('parse expression function def param', () => {
  const ast = parser.parse('(a){}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(1)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].type).toBe('VOID')
})

test('parse expression function def params', () => {
  const ast = parser.parse('(a,b){}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].args[1]).toBe('b')
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].type).toBe('VOID')
})

test('parse expression function def body', () => {
  const ast = parser.parse('(a,b){a + b}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].args[1]).toBe('b')
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].body.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[0].body.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].body.statements[0].parts[2].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[2].varName).toBe('b')
})

test('parse expression function def body #2', () => {
  const ast = parser.parse('(a,b){x := a + b\nx + 1}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].args[1]).toBe('b')
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(2)

  expect(ast.statements[0].parts[0].body.statements[0].isAssignment).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].left.name).toBe('x')  
  expect(ast.statements[0].parts[0].body.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].right.parts).toHaveLength(3)  
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[2].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[2].varName).toBe('b')
  
  expect(ast.statements[0].parts[0].body.statements[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[1].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].body.statements[1].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[1].parts[0].varName).toBe('x')
  expect(ast.statements[0].parts[0].body.statements[1].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[1].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[1].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].body.statements[1].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].body.statements[1].parts[2].value).toBe(1)
})

test('parse expression function def+call simplest', () => {
  const ast = parser.parse('(){}()')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].type).toBe('VOID')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(0)
})

test('parse expression function def+call param', () => {
  const ast = parser.parse('(a){}(1)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(1)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].type).toBe('VOID')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
})

test('parse expression function def+call params', () => {
  const ast = parser.parse('(a,b){}(1,2)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].args[1]).toBe('b')
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].type).toBe('VOID')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(2)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[1].parts[0].value).toBe(2)
})

test('parse expression function def+call body', () => {
  const ast = parser.parse('(a,b){a + b}(1,2)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].args[1]).toBe('b')
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].body.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[0].body.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].body.statements[0].parts[2].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[2].varName).toBe('b')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(2)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[1].parts[0].value).toBe(2)
})

test('parse expression function def+call body #2', () => {
  const ast = parser.parse('(a,b){x := a + b\nx + 1} ( 1 , 2 )')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('a')
  expect(ast.statements[0].parts[0].args[1]).toBe('b')
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(2)

  expect(ast.statements[0].parts[0].body.statements[0].isAssignment).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].left.name).toBe('x')  
  expect(ast.statements[0].parts[0].body.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].right.parts).toHaveLength(3)  
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[0].varName).toBe('a')
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[2].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].right.parts[2].varName).toBe('b')
  
  expect(ast.statements[0].parts[0].body.statements[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[1].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].body.statements[1].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[1].parts[0].varName).toBe('x')
  expect(ast.statements[0].parts[0].body.statements[1].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[1].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[1].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[0].body.statements[1].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].body.statements[1].parts[2].value).toBe(1)

  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(2)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[1].parts[0].value).toBe(2)
})

test('parse expression function', () => {
  const ast = parser.parse('(){}((){})')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].type).toBe('VOID')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[1].params[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].parts[1].params[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].body.statements[0].type).toBe('VOID')
})

test('parse expression function #2', () => {
  const ast = parser.parse('(x){x}(1+(){2}())')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(1)
  expect(ast.statements[0].parts[0].args[0]).toBe('x')
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[0].varName).toBe('x')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(4)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[1].params[0].parts[2].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[1].params[0].parts[2].args).toHaveLength(0)
  expect(ast.statements[0].parts[1].params[0].parts[2].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[2].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[2].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[2].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[2].body.statements[0].parts[0].value).toBe(2)
  expect(ast.statements[0].parts[1].params[0].parts[3].isCall).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[3].params).toHaveLength(0)
})

test('parse expression function #3', () => {
  const ast = parser.parse('(x){x}(1+(){2}()+3)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(1)
  expect(ast.statements[0].parts[0].args[0]).toBe('x')
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[0].varName).toBe('x')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(6)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[1].isBi).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[1].op).toBe('+')
  expect(ast.statements[0].parts[1].params[0].parts[2].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[1].params[0].parts[2].args).toHaveLength(0)
  expect(ast.statements[0].parts[1].params[0].parts[2].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[2].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[2].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[2].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[2].body.statements[0].parts[0].value).toBe(2)
  expect(ast.statements[0].parts[1].params[0].parts[3].isCall).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[3].params).toHaveLength(0)
  expect(ast.statements[0].parts[1].params[0].parts[4].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[4].isBi).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[4].op).toBe('+')
  expect(ast.statements[0].parts[1].params[0].parts[5].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[5].value).toBe(3)
})

test('parse expression function #4', () => {
  const ast = parser.parse('(x){x}((1))')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(1)
  expect(ast.statements[0].parts[0].args[0]).toBe('x')
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[0].varName).toBe('x')
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].parts[0].value).toBe(1)
})

test('parse expression function #5', () => {
  const ast = parser.parse('(f,g){f()+g()}((){1},(){2})')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(2)
  expect(ast.statements[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[0].args).toHaveLength(2)
  expect(ast.statements[0].parts[0].args[0]).toBe('f')
  expect(ast.statements[0].parts[0].args[1]).toBe('g')
  expect(ast.statements[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts).toHaveLength(5)
  expect(ast.statements[0].parts[0].body.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[0].varName).toBe('f')
  expect(ast.statements[0].parts[0].body.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[1].params).toHaveLength(0)
  expect(ast.statements[0].parts[0].body.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[2].isBi).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[2].op).toBe('+')
  expect(ast.statements[0].parts[0].body.statements[0].parts[3].isReference).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[3].varName).toBe('g')
  expect(ast.statements[0].parts[0].body.statements[0].parts[4].isCall).toBe(true)
  expect(ast.statements[0].parts[0].body.statements[0].parts[4].params).toHaveLength(0)
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('()')
  expect(ast.statements[0].parts[1].params).toHaveLength(2)
  expect(ast.statements[0].parts[1].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[1].params[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].parts[1].params[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[0].parts[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[0].parts[0].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[0].parts[0].body.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].params[1].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[1].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].parts[1].params[1].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].parts[1].params[1].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[1].params[1].parts[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[1].params[1].parts[0].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[1].params[1].parts[0].body.statements[0].parts[0].value).toBe(2)
})

test('parse expression native function', () => {
  const ast = parser.parse('1.plus(2)')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(3)
  expect(ast.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].parts[1].isAccess).toBe(true)
  expect(ast.statements[0].parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].parts[1].op).toBe('.')
  expect(ast.statements[0].parts[1].attrName).toBe('plus')  
  expect(ast.statements[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].parts[2].isAccess).toBe(true)
  expect(ast.statements[0].parts[2].isCall).toBe(true)
  expect(ast.statements[0].parts[2].op).toBe('()')
  expect(ast.statements[0].parts[2].params).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[0].isExpression).toBe(true)
  expect(ast.statements[0].parts[2].params[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[2].params[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[2].params[0].parts[0].value).toBe(2)
})

test('parse assignment number simplest', () => {
  const ast = parser.parse('a := 1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)
  
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].left.name).toBe('a')
  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
})

test('parse assignment number simplest #2', () => {
  const ast = parser.parse('a := 1 / 2')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)
  
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].left.name).toBe('a')
  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(3)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
  expect(ast.statements[0].right.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].right.parts[1].isBi).toBe(true)
  expect(ast.statements[0].right.parts[1].op).toBe('/')
  expect(ast.statements[0].right.parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[2].value).toBe(2)
})

test('parse assignment with object access', () => {
  const ast = parser.parse('o.a := 1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)
  
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isExpression).toBe(true)
  expect(ast.statements[0].left.parts).toHaveLength(2)
  expect(ast.statements[0].left.parts[0].isReference).toBe(true)
  expect(ast.statements[0].left.parts[0].varName).toBe('o')
  expect(ast.statements[0].left.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].left.parts[1].isAccess).toBe(true)
  expect(ast.statements[0].left.parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].left.parts[1].op).toBe('.')
  expect(ast.statements[0].left.parts[1].attrName).toBe('a')
  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
})

test('parse assignment with object access #2', () => {
  const ast = parser.parse('o.a.b := 1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)
  
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isExpression).toBe(true)
  expect(ast.statements[0].left.parts).toHaveLength(3)
  expect(ast.statements[0].left.parts[0].isReference).toBe(true)
  expect(ast.statements[0].left.parts[0].varName).toBe('o')
  expect(ast.statements[0].left.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].left.parts[1].isAccess).toBe(true)
  expect(ast.statements[0].left.parts[1].isObjectAccess).toBe(true)
  expect(ast.statements[0].left.parts[1].op).toBe('.')
  expect(ast.statements[0].left.parts[1].attrName).toBe('a')  
  expect(ast.statements[0].left.parts[2].isOperator).toBe(true)
  expect(ast.statements[0].left.parts[2].isAccess).toBe(true)
  expect(ast.statements[0].left.parts[2].isObjectAccess).toBe(true)
  expect(ast.statements[0].left.parts[2].op).toBe('.')
  expect(ast.statements[0].left.parts[2].attrName).toBe('b')
  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
})

test('parse assignment with array access', () => {
  const ast = parser.parse('a[3] := 1')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)
  
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isExpression).toBe(true)
  expect(ast.statements[0].left.parts).toHaveLength(2)
  expect(ast.statements[0].left.parts[0].isReference).toBe(true)
  expect(ast.statements[0].left.parts[0].varName).toBe('a')
  expect(ast.statements[0].left.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].left.parts[1].isAccess).toBe(true)
  expect(ast.statements[0].left.parts[1].isArrayAccess).toBe(true)
  expect(ast.statements[0].left.parts[1].indexes).toHaveLength(1)
  expect(ast.statements[0].left.parts[1].indexes[0].isExpression).toBe(true)
  expect(ast.statements[0].left.parts[1].indexes[0].parts).toHaveLength(1)
  expect(ast.statements[0].left.parts[1].indexes[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].left.parts[1].indexes[0].parts[0].value).toBe(3)
  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
})

test('parse assignment function def body', () => {
  const ast = parser.parse('f := (x){x := x + 1\nx + 2}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)

  expect(ast.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].left.name).toBe('f')

  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].right.parts[0].args).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].args[0]).toBe('x')
  expect(ast.statements[0].right.parts[0].body.statements).toHaveLength(2)

  expect(ast.statements[0].right.parts[0].body.statements[0].isAssignment).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[0].left.name).toBe('x')  
  expect(ast.statements[0].right.parts[0].body.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts).toHaveLength(3)  
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[0].isReference).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[0].varName).toBe('x')
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[1].isBi).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[1].op).toBe('+')
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[2].value).toBe(1)
  
  expect(ast.statements[0].right.parts[0].body.statements[1].isExpression).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[1].parts).toHaveLength(3)
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[0].isReference).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[0].varName).toBe('x')
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[1].isBi).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[1].op).toBe('+')
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[2].value).toBe(2)
})

test('parse assignment function def body #2', () => {
  const ast = parser.parse('f := (a,b){x := a + b\nx + 1}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isAssignment).toBe(true)

  expect(ast.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].left.name).toBe('f')

  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].right.parts[0].args).toHaveLength(2)
  expect(ast.statements[0].right.parts[0].args[0]).toBe('a')
  expect(ast.statements[0].right.parts[0].args[1]).toBe('b')
  expect(ast.statements[0].right.parts[0].body.statements).toHaveLength(2)

  expect(ast.statements[0].right.parts[0].body.statements[0].isAssignment).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[0].left.name).toBe('x')  
  expect(ast.statements[0].right.parts[0].body.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts).toHaveLength(3)  
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[0].isReference).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[0].varName).toBe('a')
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[1].isBi).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[1].op).toBe('+')
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[2].isReference).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[0].right.parts[2].varName).toBe('b')
  
  expect(ast.statements[0].right.parts[0].body.statements[1].isExpression).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[1].parts).toHaveLength(3)
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[0].isReference).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[0].varName).toBe('x')
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[1].isBi).toBe(true)
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[1].op).toBe('+')
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].body.statements[1].parts[2].value).toBe(1)
})

test('parse statement multiple', () => {
  const ast = parser.parse('a := 1\na + 2')
  expect(ast.statements).toHaveLength(2)
  
  expect(ast.statements[0].isAssignment).toBe(true)
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].left.name).toBe('a')  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
  
  expect(ast.statements[1].isExpression).toBe(true)
  expect(ast.statements[1].parts).toHaveLength(3)
  expect(ast.statements[1].parts[0].isReference).toBe(true)
  expect(ast.statements[1].parts[0].varName).toBe('a')
  expect(ast.statements[1].parts[1].isOperator).toBe(true)
  expect(ast.statements[1].parts[1].isBi).toBe(true)
  expect(ast.statements[1].parts[1].op).toBe('+')
  expect(ast.statements[1].parts[2].type).toBe('NUMBER')
  expect(ast.statements[1].parts[2].value).toBe(2)
})

test('parse statement multiple semicolon', () => {
  const ast = parser.parse('a := 1;a + 2')
  expect(ast.statements).toHaveLength(2)
  
  expect(ast.statements[0].isAssignment).toBe(true)
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].left.name).toBe('a')  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
  
  expect(ast.statements[1].isExpression).toBe(true)
  expect(ast.statements[1].parts).toHaveLength(3)
  expect(ast.statements[1].parts[0].isReference).toBe(true)
  expect(ast.statements[1].parts[0].varName).toBe('a')
  expect(ast.statements[1].parts[1].isOperator).toBe(true)
  expect(ast.statements[1].parts[1].isBi).toBe(true)
  expect(ast.statements[1].parts[1].op).toBe('+')
  expect(ast.statements[1].parts[2].type).toBe('NUMBER')
  expect(ast.statements[1].parts[2].value).toBe(2)
})

test('parse statement multiple #2', () => {
  const ast = parser.parse('a := 1\nb := 2\nc := a + b')
  expect(ast.statements).toHaveLength(3)
  
  expect(ast.statements[0].isAssignment).toBe(true)
  expect(ast.statements[0].left).toBeDefined()
  expect(ast.statements[0].left.isVariable).toBe(true)
  expect(ast.statements[0].left.name).toBe('a')  
  expect(ast.statements[0].right).toBeDefined()
  expect(ast.statements[0].right.isExpression).toBe(true)
  expect(ast.statements[0].right.parts).toHaveLength(1)
  expect(ast.statements[0].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].right.parts[0].value).toBe(1)
  
  expect(ast.statements[1].isAssignment).toBe(true)
  expect(ast.statements[1].left).toBeDefined()
  expect(ast.statements[1].left.isVariable).toBe(true)
  expect(ast.statements[1].left.name).toBe('b')  
  expect(ast.statements[1].right).toBeDefined()
  expect(ast.statements[1].right.isExpression).toBe(true)
  expect(ast.statements[1].right.parts).toHaveLength(1)
  expect(ast.statements[1].right.parts[0].type).toBe('NUMBER')
  expect(ast.statements[1].right.parts[0].value).toBe(2)
  
  expect(ast.statements[2].isAssignment).toBe(true)
  expect(ast.statements[2].left).toBeDefined()
  expect(ast.statements[2].left.isVariable).toBe(true)
  expect(ast.statements[2].left.name).toBe('c')  
  expect(ast.statements[2].right).toBeDefined()
  expect(ast.statements[2].right.isExpression).toBe(true)
  expect(ast.statements[2].right.parts).toHaveLength(3)
  expect(ast.statements[2].right.parts[0].isReference).toBe(true)
  expect(ast.statements[2].right.parts[0].varName).toBe('a')
  expect(ast.statements[2].right.parts[1].isOperator).toBe(true)
  expect(ast.statements[2].right.parts[1].isBi).toBe(true)
  expect(ast.statements[2].right.parts[1].op).toBe('+')
  expect(ast.statements[2].right.parts[2].isReference).toBe(true)
  expect(ast.statements[2].right.parts[2].varName).toBe('b')
})

test('parse statement while', () => {
  const ast = parser.parse('while true {}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
})

test('parse statement while #2', () => {
  const ast = parser.parse('while (true) {}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].isExpression).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
})

test('parse statement while #3', () => {
  const ast = parser.parse('while 1 < 2 {}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(3)
  expect(ast.statements[0].condition.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].condition.parts[0].value).toBe(1)
  expect(ast.statements[0].condition.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].condition.parts[1].isBi).toBe(true)
  expect(ast.statements[0].condition.parts[1].op).toBe('<')
  expect(ast.statements[0].condition.parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].condition.parts[2].value).toBe(2)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
})

test('parse statement while #4', () => { // functions in the condition must be enclosed in quotations
  const ast = parser.parse('while ((){true}()) {}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].isExpression).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts).toHaveLength(2)
  expect(ast.statements[0].condition.parts[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].condition.parts[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].condition.parts[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].parts[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].parts[0].body.statements[0].parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].parts[0].body.statements[0].parts[0].value).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[1].params).toHaveLength(0)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
})

test('parse statement while #5', () => { // functions in the condition must be enclosed in quotations
  const ast = parser.parse('while ((){true}() | false) {}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].isExpression).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts).toHaveLength(4)
  expect(ast.statements[0].condition.parts[0].parts[0].type).toBe('FUNCTION')
  expect(ast.statements[0].condition.parts[0].parts[0].args).toHaveLength(0)
  expect(ast.statements[0].condition.parts[0].parts[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].parts[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].parts[0].body.statements[0].parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].parts[0].body.statements[0].parts[0].value).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[1].isOperator).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[1].isCall).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[1].params).toHaveLength(0)
  expect(ast.statements[0].condition.parts[0].parts[2].isOperator).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[2].isBi).toBe(true)
  expect(ast.statements[0].condition.parts[0].parts[2].op).toBe('|')
  expect(ast.statements[0].condition.parts[0].parts[3].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].parts[3].value).toBe(false)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
})

test('parse statement while #6', () => {
  const ast = parser.parse('while true {1}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].body.statements[0].parts[0].value).toBe(1)
})

test('parse statement while #7', () => {
  const ast = parser.parse('while true {1}\nwhile false {2}')
  expect(ast.statements).toHaveLength(2)
  expect(ast.statements[0].isWhile).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].body.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[1].isWhile).toBe(true)
  expect(ast.statements[1].condition.isExpression).toBe(true)
  expect(ast.statements[1].condition.parts).toHaveLength(1)
  expect(ast.statements[1].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[1].condition.parts[0].value).toBe(false)
  expect(ast.statements[1].body.statements).toHaveLength(1)
  expect(ast.statements[1].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[1].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[1].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[1].body.statements[0].parts[0].value).toBe(2)
})

test('parse statement while #8', () => {
  const ast = parser.parse('a := 0\nb := 0\nwhile a < 10 { b := b + 1\na := a + 2 }\nb')
  expect(ast.statements).toHaveLength(4)
  expect(ast.statements[0].isAssignment).toBe(true)
  expect(ast.statements[1].isAssignment).toBe(true)
  expect(ast.statements[2].isWhile).toBe(true)
  expect(ast.statements[2].condition.isExpression).toBe(true)
  expect(ast.statements[2].condition.parts).toHaveLength(3)
  expect(ast.statements[2].condition.parts[0].isReference).toBe(true)
  expect(ast.statements[2].condition.parts[0].varName).toBe('a')
  expect(ast.statements[2].condition.parts[1].isBi).toBe(true)
  expect(ast.statements[2].condition.parts[1].op).toBe('<')
  expect(ast.statements[2].condition.parts[2].type).toBe('NUMBER')
  expect(ast.statements[2].condition.parts[2].value).toBe(10)
  expect(ast.statements[2].body.statements).toHaveLength(2)
  expect(ast.statements[2].body.statements[0].isAssignment).toBe(true)
  expect(ast.statements[2].body.statements[1].isAssignment).toBe(true)
  expect(ast.statements[3].isExpression).toBe(true)
})

test('parse comment', () => {  // comment must be in the beginning of a statement
  const ast = parser.parse('//a')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #1', () => {
  const ast = parser.parse('//a := [1]')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #2', () => {
  const ast = parser.parse('// !@#$%^&*()')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #3', () => {
  const ast = parser.parse('// !@#$%^&*()')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #4', () => {
  const ast = parser.parse('//')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #5', () => {
  const ast = parser.parse('////')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #6', () => {
  const ast = parser.parse('// //')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #7', () => {
  const ast = parser.parse('  // //')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #8', () => {
  const ast = parser.parse('1  // //')
  expect(ast.statements).toHaveLength(1)
})

test('parse comment #9', () => {
  const ast = parser.parse('// c\n1  // a // b\n// d')
  expect(ast.statements).toHaveLength(1)
})

test('parse comment #10', () => {
  const ast = parser.parse('1\n//x')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].parts[0].value).toBe(1)
})

test('parse comment #11', () => {
  const ast = parser.parse('//    _if1 := _if1 - 1')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #12', () => {
  const ast = parser.parse('//if _if1 > 3 {\n//    _if1 := _if1 - 1')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #13', () => {
  const ast = parser.parse('if true { // c1\n a := 1 // c2\n}// c3 \n// c4')
  expect(ast.statements).toHaveLength(1)
})

test('parse comment #14', () => {
  const ast = parser.parse('"//"')
  expect(ast.statements).toHaveLength(1)
})

test('parse comment #15', () => {
  const ast = parser.parse('//""')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #16', () => {
  const ast = parser.parse('//')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #17', () => {
  const ast = parser.parse("'//'")
  expect(ast.statements).toHaveLength(1)
})

test('parse comment #18', () => {
  const ast = parser.parse('//a')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #19', () => {
  const ast = parser.parse('// a')
  expect(ast.statements).toHaveLength(0)
})

test('parse comment #20', () => {
  const ast = parser.parse('1 // a')
  expect(ast.statements).toHaveLength(1)
})

test('parse comment #21', () => {
  const ast = parser.parse('1 ///////////// /////// //////')
  expect(ast.statements).toHaveLength(1)
})

test('parse comment #22', () => {
  const ast = parser.parse('"/////////////\n///////\n\n//////"')
  expect(ast.statements).toHaveLength(1)
})

test('parse if', () => {
  const ast = parser.parse('if true {}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isIf).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
  expect(ast.statements[0].elseBody).toBeFalsy()
})

test('parse if else', () => {
  const ast = parser.parse('if true {} else {}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isIf).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
  expect(ast.statements[0].elseBody.statements).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].type).toBe('VOID')
})

test('parse if else newline', () => {
  const ast = parser.parse('if true {\n}\nelse {\n}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isIf).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
  expect(ast.statements[0].elseBody.statements).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].type).toBe('VOID')
})

test('parse if else localized', () => {
  const ast = parser.parse('pokud true {} jinak {}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isIf).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].type).toBe('VOID')
  expect(ast.statements[0].elseBody.statements).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].type).toBe('VOID')
})

test('parse if else #2', () => {
  const ast = parser.parse('if true {1} else {2}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isIf).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].body.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[0].elseBody.statements).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].elseBody.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].elseBody.statements[0].parts[0].value).toBe(2)
})

test('parse if else #3', () => {
  const ast = parser.parse('if true {a} else {b}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isIf).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].body.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].elseBody.statements).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].elseBody.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].elseBody.statements[0].parts[0].varName).toBe('b')
})

test('parse if else #4', () => {
  const ast = parser.parse('if 1 > 2 {a} else {b}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isIf).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(3)
  expect(ast.statements[0].condition.parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].condition.parts[0].value).toBe(1)
  expect(ast.statements[0].condition.parts[1].isOperator).toBe(true)
  expect(ast.statements[0].condition.parts[1].isBi).toBe(true)
  expect(ast.statements[0].condition.parts[1].op).toBe('>')
  expect(ast.statements[0].condition.parts[2].type).toBe('NUMBER')
  expect(ast.statements[0].condition.parts[2].value).toBe(2)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].body.statements[0].parts[0].varName).toBe('a')
  expect(ast.statements[0].elseBody.statements).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].elseBody.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].parts[0].isReference).toBe(true)
  expect(ast.statements[0].elseBody.statements[0].parts[0].varName).toBe('b')
})

test('parse if else #5', () => {
  const ast = parser.parse('if true {1}\nif false {2} else {3}')
  expect(ast.statements).toHaveLength(2)
  expect(ast.statements[0].isIf).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].body.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[1].isIf).toBe(true)
  expect(ast.statements[1].condition.isExpression).toBe(true)
  expect(ast.statements[1].condition.parts).toHaveLength(1)
  expect(ast.statements[1].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[1].condition.parts[0].value).toBe(false)
  expect(ast.statements[1].body.statements).toHaveLength(1)
  expect(ast.statements[1].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[1].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[1].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[1].body.statements[0].parts[0].value).toBe(2)
  expect(ast.statements[1].elseBody.statements).toHaveLength(1)
  expect(ast.statements[1].elseBody.statements[0].isExpression).toBe(true)
  expect(ast.statements[1].elseBody.statements[0].parts).toHaveLength(1)
  expect(ast.statements[1].elseBody.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[1].elseBody.statements[0].parts[0].value).toBe(3)
})

test('parse if else #6', () => {
  const ast = parser.parse('a := 0\nb := 0\nif a < 10 { b := b + 1\na := a + 2 }\nb')
  expect(ast.statements).toHaveLength(4)
  expect(ast.statements[0].isAssignment).toBe(true)
  expect(ast.statements[1].isAssignment).toBe(true)
  expect(ast.statements[2].isIf).toBe(true)
  expect(ast.statements[2].condition.isExpression).toBe(true)
  expect(ast.statements[2].condition.parts).toHaveLength(3)
  expect(ast.statements[2].condition.parts[0].isReference).toBe(true)
  expect(ast.statements[2].condition.parts[0].varName).toBe('a')
  expect(ast.statements[2].condition.parts[1].isBi).toBe(true)
  expect(ast.statements[2].condition.parts[1].op).toBe('<')
  expect(ast.statements[2].condition.parts[2].type).toBe('NUMBER')
  expect(ast.statements[2].condition.parts[2].value).toBe(10)
  expect(ast.statements[2].body.statements).toHaveLength(2)
  expect(ast.statements[2].body.statements[0].isAssignment).toBe(true)
  expect(ast.statements[2].body.statements[1].isAssignment).toBe(true)
  expect(ast.statements[3].isExpression).toBe(true)
})

test('parse if elseif else', () => {
  const ast = parser.parse('if true {1}\nelse if false {2}\nelse {3}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isIf).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].body.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[0].elseBody.statements).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].isIf).toBe(true)
  expect(ast.statements[0].elseBody.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].elseBody.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].elseBody.statements[0].condition.parts[0].value).toBe(false)
  expect(ast.statements[0].elseBody.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].elseBody.statements[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].elseBody.statements[0].body.statements[0].parts[0].value).toBe(2)
  expect(ast.statements[0].elseBody.statements[0].elseBody.statements).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].elseBody.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].elseBody.statements[0].elseBody.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].elseBody.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].elseBody.statements[0].elseBody.statements[0].parts[0].value).toBe(3)
})

test('parse if elseif else #2', () => {
  const ast = parser.parse('if true {1}\nelse if false {2}\nelse {3}\n4')
  expect(ast.statements).toHaveLength(2)
  expect(ast.statements[0].isIf).toBe(true)
  expect(ast.statements[1].isExpression).toBe(true)
  expect(ast.statements[1].parts).toHaveLength(1)
  expect(ast.statements[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[1].parts[0].value).toBe(4)
})

test('parse if elseif', () => {
  const ast = parser.parse('if true {1}\nelse if false {2}')
  expect(ast.statements).toHaveLength(1)
  expect(ast.statements[0].isIf).toBe(true)
  expect(ast.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].condition.parts[0].value).toBe(true)
  expect(ast.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].body.statements[0].parts[0].value).toBe(1)
  expect(ast.statements[0].elseBody.statements).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].isIf).toBe(true)
  expect(ast.statements[0].elseBody.statements[0].condition.isExpression).toBe(true)
  expect(ast.statements[0].elseBody.statements[0].condition.parts).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].condition.parts[0].type).toBe('BOOLEAN')
  expect(ast.statements[0].elseBody.statements[0].condition.parts[0].value).toBe(false)
  expect(ast.statements[0].elseBody.statements[0].body.statements).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].body.statements[0].isExpression).toBe(true)
  expect(ast.statements[0].elseBody.statements[0].body.statements[0].parts).toHaveLength(1)
  expect(ast.statements[0].elseBody.statements[0].body.statements[0].parts[0].type).toBe('NUMBER')
  expect(ast.statements[0].elseBody.statements[0].body.statements[0].parts[0].value).toBe(2)
  expect(ast.statements[0].elseBody.statements[0].elseBody).toBeFalsy()
})

test('parse if elseif #2', () => {
  const ast = parser.parse('if true {1}\nelse if false {2}\n3')
  expect(ast.statements).toHaveLength(2)
  expect(ast.statements[0].isIf).toBe(true)
  expect(ast.statements[1].isExpression).toBe(true)
  expect(ast.statements[1].parts).toHaveLength(1)
  expect(ast.statements[1].parts[0].type).toBe('NUMBER')
  expect(ast.statements[1].parts[0].value).toBe(3)
})

test('parse max steps', () => {
  const maxSteps_bak = parser.maxSteps
  parser.maxSteps = 2
  try {
    expect(() => parser.parse('1 + 2 * 3')).toThrow()
  } finally {
    parser.maxSteps = maxSteps_bak
  }
})

test('parse max steps ok', () => {
  const maxSteps_bak = parser.maxSteps
  parser.maxSteps = 100
  try {
    const ast = parser.parse('1 + 2 * 3')
    expect(ast.statements).toHaveLength(1)
    expect(ast.statements[0].isExpression).toBe(true)
    expect(ast.statements[0].parts).toHaveLength(5)
  } finally {
    parser.maxSteps = maxSteps_bak
  }
})